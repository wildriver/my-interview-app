<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Interviewer (2026-02-09)</title>
    <style>
        body { font-family: "Helvetica Neue", Arial, sans-serif; max-width: 900px; margin: 0 auto; padding: 20px; background-color: #f0f2f5; color: #333; position: relative; }
        .container { background: white; padding: 30px; border-radius: 12px; box-shadow: 0 2px 10px rgba(0,0,0,0.05); }
        h2 { text-align: center; color: #2c3e50; margin-bottom: 5px; }
        .subtitle { text-align: center; color: #7f8c8d; font-size: 0.9em; margin-bottom: 20px; }
        
        #timer {
            position: absolute; top: 20px; right: 20px;
            font-size: 1.5em; font-weight: bold; color: #2c3e50;
            background: #fff; padding: 5px 15px; border-radius: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }

        .status-box { padding: 12px; margin-bottom: 10px; text-align: center; font-weight: bold; border-radius: 8px; transition: all 0.3s; }
        .status-idle { background-color: #e9ecef; color: #6c757d; }
        .status-listening { background-color: #ffebee; color: #c62828; border: 1px solid #ffcdd2; animation: pulse 2s infinite; }
        .status-thinking { background-color: #e3f2fd; color: #1565c0; border: 1px solid #bbdefb; }
        .status-speaking { background-color: #e8f5e9; color: #2e7d32; border: 1px solid #c8e6c9; }
        .status-finishing { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .status-error { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }

        #visualizer-container { height: 60px; background-color: #222; border-radius: 8px; margin-bottom: 20px; display: flex; overflow: hidden; }
        canvas { display: block; width: 100%; height: 100%; }
        .inactive-visualizer { opacity: 0.3; filter: grayscale(100%); }
        
        .content-wrapper { display: flex; gap: 20px; flex-wrap: wrap; }
        .chat-section { flex: 1; min-width: 300px; }
        .summary-section { flex: 1; min-width: 300px; display: none; }
        #chat-log { height: 400px; overflow-y: auto; border: 1px solid #eee; padding: 20px; background: #fafafa; border-radius: 8px; box-shadow: inset 0 1px 3px rgba(0,0,0,0.03); }
        
        .message { margin-bottom: 15px; padding: 12px 16px; border-radius: 12px; max-width: 90%; line-height: 1.5; }
        .role-user { background-color: #f55036; color: white; margin-left: auto; border-bottom-right-radius: 2px; }
        .role-ai { background-color: #fff; border: 1px solid #eee; margin-right: auto; border-bottom-left-radius: 2px; }
        
        #summary-box { height: 350px; overflow-y: auto; border: 1px solid #eee; padding: 20px; background: #fff; border-radius: 8px; line-height: 1.8; white-space: pre-wrap; margin-bottom: 10px; box-shadow: 0 1px 3px rgba(0,0,0,0.05); }
        .summary-title { font-weight: bold; color: #2c3e50; margin-bottom: 10px; border-left: 4px solid #f55036; padding-left: 10px; }

        /* --- ãƒœã‚¿ãƒ³ã‚¨ãƒªã‚¢ã®ã‚¹ã‚¿ã‚¤ãƒ« --- */
        .controls {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #eee;
        }

        /* å…±é€šãƒœã‚¿ãƒ³ã‚¹ã‚¿ã‚¤ãƒ« */
        .btn {
            padding: 14px 30px; font-size: 1em; font-weight: bold;
            cursor: pointer; border: none; border-radius: 50px;
            color: white; transition: all 0.2s; width: 100%;
        }
        .btn:hover { opacity: 0.9; transform: translateY(-1px); }
        .btn:active { transform: translateY(1px); }

        .btn-start { background-color: #f55036; max-width: 400px; display: block; margin: 0 auto; }
        .btn-start:hover { background-color: #d43f29; }
        .btn-abort { background-color: #95a5a6; }
        .btn-abort:hover { background-color: #7f8c8d; }
        .btn-finish { background-color: #f55036; }
        .btn-finish:hover { background-color: #d43f29; }
        .btn-back { background-color: #f55036; max-width: 400px; display: block; margin: 0 auto; }
        .btn-back:hover { background-color: #d43f29; }

        /* ã‚¤ãƒ³ã‚¿ãƒ“ãƒ¥ãƒ¼æ“ä½œã‚¨ãƒªã‚¢ */
        .interview-actions {
            background: #fafafa;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            border: 1px solid #eee;
        }

        /* ã‚¹ã‚­ãƒƒãƒ—ãƒ»è¿”ä¿¡ãƒœã‚¿ãƒ³è¡Œ */
        #skip-btn-container {
            display: flex; justify-content: center; gap: 10px;
            margin-bottom: 12px; min-height: 36px;
        }
        #skip-btn {
            background-color: #6c757d; color: white; border: none;
            padding: 8px 20px; border-radius: 50px; font-weight: bold; font-size: 0.85em;
            cursor: pointer; display: none; transition: all 0.2s;
        }
        #skip-btn:hover { background-color: #5a6268; }
        #reply-btn {
            background-color: #e67e22; color: white; border: none;
            padding: 8px 20px; border-radius: 50px; font-weight: bold; font-size: 0.85em;
            cursor: pointer; display: inline-block; transition: all 0.2s;
        }
        #reply-btn:hover { background-color: #d35400; }

        /* ãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ› */
        .text-input-row {
            display: flex; gap: 8px; max-width: 100%; margin: 0 auto 12px;
        }
        .text-input-row input {
            flex: 1; padding: 9px 14px; border: 1px solid #bdc3c7; border-radius: 50px;
            font-size: 0.95em; outline: none; transition: border-color 0.2s;
        }
        .text-input-row input:focus { border-color: #f55036; box-shadow: 0 0 0 2px rgba(245,80,54,0.1); }
        .text-input-row button {
            padding: 9px 18px; background-color: #f55036; color: white; border: none;
            border-radius: 50px; font-weight: bold; font-size: 0.85em; cursor: pointer;
            white-space: nowrap; transition: all 0.2s;
        }
        .text-input-row button:hover { background-color: #d43f29; }

        /* æ¬¡ã®è©±é¡Œãƒœã‚¿ãƒ³ */
        #next-topic-btn {
            background-color: #3498db; color: white; border: none;
            padding: 8px 20px; border-radius: 50px; font-weight: bold; font-size: 0.85em;
            cursor: pointer; display: inline-block; transition: all 0.2s;
        }
        #next-topic-btn:hover { background-color: #2980b9; }

        /* å®Ÿè¡Œä¸­ã®ãƒ¡ã‚¤ãƒ³ãƒœã‚¿ãƒ³ã‚³ãƒ³ãƒ†ãƒŠï¼ˆæ¨ªä¸¦ã³ï¼‰ */
        .running-controls {
            display: flex; gap: 12px; justify-content: center;
            width: 100%; max-width: 500px; margin: 0 auto;
        }
        .running-controls button { flex: 1; font-size: 0.95em; padding: 12px 20px; }

        /* ãƒ“ãƒ«ãƒ‰ãƒãƒ¼ã‚¸ãƒ§ãƒ³ */
        .build-version { text-align: right; font-size: 0.75em; color: #bdc3c7; margin-top: 10px; }

        .copy-btn { width: 100%; padding: 10px; background-color: #f55036; color: white; border: none; border-radius: 50px; cursor: pointer; font-weight: bold; transition: all 0.2s; }
        .copy-btn:hover { background-color: #d43f29; }
        .copy-btn:disabled, .btn-back:disabled { background-color: #bdc3c7; cursor: not-allowed; opacity: 0.7; }

        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.6; } 100% { opacity: 1; } }

        /* ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰ */
        .debug-toggle-container {
            display: flex;
            justify-content: flex-end;
            margin-top: 15px;
            padding-top: 10px;
        }
        .debug-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.85em;
            color: #7f8c8d;
            cursor: pointer;
        }
        .debug-toggle input[type="checkbox"] {
            width: 16px;
            height: 16px;
        }
        .debug-box {
            display: none;
            margin-top: 15px;
            padding: 15px;
            background: #1e1e1e;
            border-radius: 8px;
            color: #00ff00;
            font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
            font-size: 0.8em;
            max-height: 300px;
            overflow-y: auto;
        }
        .debug-box.active { display: block; }
        .debug-entry {
            margin-bottom: 12px;
            padding-bottom: 12px;
            border-bottom: 1px solid #333;
        }
        .debug-entry:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }
        .debug-timestamp {
            color: #888;
            font-size: 0.9em;
            margin-bottom: 4px;
        }
        .debug-status {
            color: #ffd700;
            font-weight: bold;
            margin-bottom: 4px;
        }
        .debug-prompt {
            white-space: pre-wrap;
            word-break: break-word;
            color: #7fdbff;
            max-height: 150px;
            overflow-y: auto;
            padding: 8px;
            background: #2a2a2a;
            border-radius: 4px;
            margin-top: 4px;
        }
        .debug-history {
            color: #ff6b6b;
            margin-top: 4px;
        }
    </style>
</head>
<body>

<div id="timer">00:00</div>

<div class="container">
    <h2 id="page-title">ã‚¤ãƒ³ã‚¿ãƒ“ãƒ¥ãƒ¼</h2>
    <div class="subtitle" id="page-topics">èª­ã¿è¾¼ã¿ä¸­...</div>
    <div id="status" class="status-box status-idle">å¾…æ©Ÿä¸­</div>
    
    <div id="visualizer-container" class="inactive-visualizer">
        <canvas id="visualizer" width="600" height="100"></canvas>
    </div>

    <div class="content-wrapper">
        <div class="chat-section"><div id="chat-log"></div></div>
        <div class="summary-section" id="summary-section">
            <div class="summary-title">ğŸ“ ã‚¤ãƒ³ã‚¿ãƒ“ãƒ¥ãƒ¼çµæœã‚µãƒãƒªãƒ¼</div>
            <div id="summary-box">ã“ã“ã«çµæœãŒè¡¨ç¤ºã•ã‚Œã¾ã™...</div>
            <button id="copy-btn" class="copy-btn" onclick="copySummary()" disabled>ğŸ“‹ ã‚µãƒãƒªãƒ¼ã‚’ã‚³ãƒ”ãƒ¼</button>
        </div>
    </div>

    <div class="controls">
        <div id="ctrl-idle">
            <button class="btn btn-start" onclick="startInterview()">ã‚¤ãƒ³ã‚¿ãƒ“ãƒ¥ãƒ¼é–‹å§‹</button>
        </div>

        <div id="interview-actions-wrapper" class="interview-actions" style="display:none;">
            <div id="skip-btn-container">
                <button id="skip-btn" onclick="skipSpeech()">â© èª­ã¿ä¸Šã’Skip</button>
            </div>

            <div id="text-input-container" style="display:none;">
                <div class="text-input-row">
                    <input type="text" id="text-input" placeholder="ãƒ†ã‚­ã‚¹ãƒˆã§å…¥åŠ›..." onkeydown="if(event.key==='Enter')sendTextInput()">
                    <button onclick="sendTextInput()">é€ä¿¡</button>
                </div>
            </div>

            <div id="ctrl-actions" style="display:none; text-align:center;">
                <button id="reply-btn" onclick="forceReply()">ğŸ’¬ è¿”ä¿¡ã—ã¦</button>
                <button id="next-topic-btn" onclick="requestNextTopic()">â­ æ¬¡ã®è©±é¡Œã¸</button>
            </div>
        </div>

        <div id="ctrl-running" class="running-controls" style="display:none;">
            <button class="btn btn-abort" onclick="abortInterview()">ä¸­æ­¢ã™ã‚‹</button>
            <button class="btn btn-finish" onclick="forceFinish()">çµ‚äº†ã™ã‚‹</button>
        </div>

        <div id="ctrl-finished" style="display:none;">
            <button id="back-btn" class="btn btn-back" onclick="window.location.href='index.html'" disabled>è¨­å®šç”»é¢ã«æˆ»ã‚‹</button>
        </div>
    </div>

    <!-- ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰ -->
    <div class="debug-toggle-container">
        <label class="debug-toggle">
            <input type="checkbox" id="debug-mode-toggle" onchange="toggleDebugMode()">
            <span>ğŸ› Debug Mode</span>
        </label>
    </div>
    <div id="debug-box" class="debug-box">
        <div style="color: #888; margin-bottom: 10px;">APIã‚³ãƒ¼ãƒ«ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆæƒ…å ±ãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™</div>
    </div>
    <div class="build-version">Build: 2026-02-09 09:30</div>
</div>

<script>
    const DB_NAME = "InterviewDB";
    const DB_VERSION = 1;
    const STORE_NAME = "archives";

    let CONFIG = {};
    let isInterviewerSpeaking = false;
    let isThinking = false;
    let conversationHistory = [];
    let synth = window.speechSynthesis;
    let audioContext, analyser, dataArray, canvasCtx, visualizerFrame;
    let availableVoices = [];

    let timerInterval;
    let startTime;

    let currentTopicIndex = 0;

    // ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰é–¢é€£
    let debugMode = false;
    let promptLog = [];  // å„APIã‚³ãƒ¼ãƒ«ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆæƒ…å ±ã‚’è¨˜éŒ² 

    window.speechSynthesis.onvoiceschanged = () => { availableVoices = window.speechSynthesis.getVoices(); };

    window.onload = () => {
        const storedConfig = localStorage.getItem('interviewConfig');
        if (storedConfig) {
            CONFIG = JSON.parse(storedConfig);
        } else {
            alert("è¨­å®šç”»é¢ã‹ã‚‰èµ·å‹•ã—ã¦ãã ã•ã„ã€‚");
            window.location.href = 'index.html';
            return;
        }

        document.getElementById('page-title').innerText = CONFIG.title;
        const sttLabel = (CONFIG.sttMode === 'webspeech') ? 'Web Speech API' : 'Groq Whisper';
        document.getElementById('page-topics').innerText = "èããŸã„ã“ã¨: " + CONFIG.topics.length + "é …ç›® | éŸ³å£°èªè­˜: " + sttLabel;

        setupVisualizerCanvas();
        setButtonState("IDLE");
    };

    function setButtonState(state) {
        document.getElementById('ctrl-idle').style.display = 'none';
        document.getElementById('ctrl-running').style.display = 'none';
        document.getElementById('ctrl-finished').style.display = 'none';
        document.getElementById('interview-actions-wrapper').style.display = 'none';
        document.getElementById('ctrl-actions').style.display = 'none';
        document.getElementById('text-input-container').style.display = 'none';
        document.getElementById('skip-btn').style.display = 'none';

        if (state === "IDLE") {
            document.getElementById('ctrl-idle').style.display = 'block';
        } else if (state === "RUNNING") {
            document.getElementById('interview-actions-wrapper').style.display = 'block';
            document.getElementById('ctrl-running').style.display = 'flex';
            document.getElementById('ctrl-actions').style.display = 'block';
            document.getElementById('text-input-container').style.display = 'block';
        } else if (state === "FINISHED") {
            document.getElementById('ctrl-finished').style.display = 'block';
        }
    }

    function abortInterview() {
        if (confirm("ã‚¤ãƒ³ã‚¿ãƒ“ãƒ¥ãƒ¼ã‚’ä¸­æ­¢ã—ã¾ã™ã‹ï¼Ÿ\nï¼ˆå†…å®¹ã¯ä¿å­˜ã•ã‚Œã¾ã›ã‚“ï¼‰")) {
            interviewRunning = false;
            stopRecognition();
            clearInterval(timerInterval);
            window.location.href = 'index.html';
        }
    }

    function forceFinish() {
        if (confirm("ç¾åœ¨ã¾ã§ã®å†…å®¹ã§ã‚¤ãƒ³ã‚¿ãƒ“ãƒ¥ãƒ¼ã‚’çµ‚äº†ã—ã€ã‚µãƒãƒªãƒ¼ã‚’ä½œæˆã—ã¾ã™ã‹ï¼Ÿ")) {
            interviewRunning = false;
            stopTimer();
            stopRecognition();
            updateStatus('finishing', 'çµ‚äº†å‡¦ç†ä¸­... ã‚µãƒãƒªãƒ¼ã‚’ä½œæˆã—ã¾ã™');
            document.getElementById('ctrl-running').style.display = 'none';
            document.getElementById('interview-actions-wrapper').style.display = 'none';
            generateSummary();
        }
    }

    function startTimer() {
        startTime = Date.now();
        clearInterval(timerInterval);
        timerInterval = setInterval(() => {
            const diff = Date.now() - startTime;
            const mins = Math.floor(diff / 60000);
            const secs = Math.floor((diff % 60000) / 1000);
            document.getElementById('timer').innerText = 
                (mins < 10 ? "0" : "") + mins + ":" + (secs < 10 ? "0" : "") + secs;
        }, 1000);
    }

    function stopTimer() {
        clearInterval(timerInterval);
    }

    function skipSpeech() {
        if (synth.speaking || synth.pending) {
            synth.cancel();
            isInterviewerSpeaking = false;
            isThinking = false;
            stopSpeechInterruptionDetection();
            document.getElementById('skip-btn').style.display = 'none';

            if (!document.querySelector('.status-finishing')) {
                startListening();
            }
        }
    }

    async function startInterview() {
        if (!CONFIG.apiKey) return alert("APIã‚­ãƒ¼ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“");

        conversationHistory = [];
        currentTopicIndex = 0;
        promptLog = [];
        consecutiveSilenceCount = 0;
        sttMode = CONFIG.sttMode || 'groq';

        document.getElementById('chat-log').innerHTML = '';
        document.getElementById('summary-section').style.display = 'none';
        document.getElementById('summary-box').innerText = '...';
        document.getElementById('debug-box').innerHTML = '<div style="color: #888; margin-bottom: 10px;">APIã‚³ãƒ¼ãƒ«ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆæƒ…å ±ãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™</div>';

        await initAudioContext();
        setButtonState("RUNNING");
        interviewRunning = true;
        startTimer();

        const intro = "ã“ã‚“ã«ã¡ã¯ã€‚ã‚¤ãƒ³ã‚¿ãƒ“ãƒ¥ãƒ¼ã‚’å§‹ã‚ã¾ã™ã€‚ã¾ãšã¯è‡ªå·±ç´¹ä»‹ã‚’ãŠé¡˜ã„ã—ã¾ã™ã€‚";
        addMessage('ai', intro);
        conversationHistory.push({ role: "assistant", content: intro });
        speak(intro);
    }

    function stopRecognition() {
        isInterviewerSpeaking = false;
        isThinking = false;
        stopSpeechInterruptionDetection();
        stopListening();
        synth.cancel();
        toggleVisualizer(false);
    }

    async function processUserResponse(userText) {
        console.log('[DEBUG] processUserResponse called with:', userText.substring(0, 50));
        isThinking = true;
        updateStatus('thinking', 'AIãŒè€ƒãˆã¦ã„ã¾ã™ (Groq)...');

        conversationHistory.push({ role: "user", content: userText });

        // çµ‚äº†å¸Œæœ›ãƒã‚§ãƒƒã‚¯
        let forceEnd = false;
        if (userText.includes("ã‚„ã‚ã¦") || userText.includes("çµ‚äº†ã—ã¦") || userText.includes("ã‚¹ãƒˆãƒƒãƒ—")) {
            forceEnd = true;
        }

        try {
            const systemPrompt = buildDynamicPrompt(forceEnd);
            const rawAiText = await callGroqAPI(conversationHistory, systemPrompt);

            // [[NEXT]]ãƒãƒ¼ã‚«ãƒ¼ã‚’æ¤œå‡ºã—ã¦ãƒˆãƒ”ãƒƒã‚¯ç§»è¡Œ
            let aiText = rawAiText;
            if (rawAiText.includes("[[NEXT]]")) {
                aiText = rawAiText.replace("[[NEXT]]", "").trim();
                currentTopicIndex++;
                console.log(`Topic advanced to: ${currentTopicIndex}`);
            }

            addMessage('ai', aiText);
            conversationHistory.push({ role: "assistant", content: aiText });

            if (aiText.includes("çµ‚äº†ã—ã¾ã™") || aiText.includes("çµ‚ã‚ã‚Šã¾ã™")) {
                interviewRunning = false;
                stopTimer();
                updateStatus('finishing', 'æŒ¨æ‹¶ã®èª­ã¿ä¸Šã’ä¸­...');

                speak(aiText, () => {
                    updateStatus('finishing', 'ã‚µãƒãƒªãƒ¼ä½œæˆä¸­...');
                    stopRecognition();
                    generateSummary();
                });
            } else {
                speak(aiText);
            }

        } catch (error) {
            console.error(error);
            addMessage('ai', `<span class="error-msg">${error.message}</span>`);
            speak("ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚");
            updateStatus('error', 'ã‚¨ãƒ©ãƒ¼');
            isThinking = false;
        }
    }

    function buildDynamicPrompt(forceEnd = false) {
        const contextText = CONFIG.context ? `\n# Pre-knowledge / Background Context\n${CONFIG.context}\n` : "";

        // ãƒˆãƒ”ãƒƒã‚¯ä¸€è¦§ã¨ç¾åœ¨ä½ç½®
        const topicsList = CONFIG.topics.map((t, i) => {
            if (i < currentTopicIndex) return `  âœ“ ${t} (å®Œäº†)`;
            if (i === currentTopicIndex) return `  â–¶ ${t} (ç¾åœ¨)`;
            return `  â—‹ ${t}`;
        }).join('\n');

        const currentTopic = CONFIG.topics[currentTopicIndex] || null;
        const remainingCount = CONFIG.topics.length - currentTopicIndex;
        const isLastTopic = currentTopicIndex >= CONFIG.topics.length - 1;
        const allDone = currentTopicIndex >= CONFIG.topics.length;

        // çŠ¶æ³ã«å¿œã˜ãŸæŒ‡ç¤º
        let situationInstruction = "";
        if (forceEnd) {
            situationInstruction = `
## ç¾åœ¨ã®çŠ¶æ³: ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒçµ‚äº†ã‚’å¸Œæœ›
ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒçµ‚äº†ã‚’å¸Œæœ›ã—ã¦ã„ã¾ã™ã€‚æ„Ÿè¬ã‚’ä¼ãˆã€ã€Œãã‚Œã§ã¯ã‚¤ãƒ³ã‚¿ãƒ“ãƒ¥ãƒ¼ã‚’çµ‚äº†ã—ã¾ã™ã€ã¨è¨€ã£ã¦ç· ã‚ããã£ã¦ãã ã•ã„ã€‚`;
        } else if (allDone) {
            situationInstruction = `
## ç¾åœ¨ã®çŠ¶æ³: å…¨ãƒˆãƒ”ãƒƒã‚¯å®Œäº†
å…¨ã¦ã®ãƒˆãƒ”ãƒƒã‚¯ãŒçµ‚ã‚ã‚Šã¾ã—ãŸã€‚ã€Œæœ€å¾Œã«ä½•ã‹è¨€ã„æ®‹ã—ãŸã“ã¨ã¯ã‚ã‚Šã¾ã™ã‹ï¼Ÿã€ã¨èã„ã¦ãã ã•ã„ã€‚
ç›¸æ‰‹ãŒç‰¹ã«ãªã„ã¨è¨€ã£ãŸã‚‰ã€æ„Ÿè¬ã‚’ä¼ãˆã€Œãã‚Œã§ã¯ã‚¤ãƒ³ã‚¿ãƒ“ãƒ¥ãƒ¼ã‚’çµ‚äº†ã—ã¾ã™ã€ã¨ç· ã‚ããã£ã¦ãã ã•ã„ã€‚`;
        } else {
            const depthHint = CONFIG.depth === "deep"
                ? "ï¼ˆã˜ã£ãã‚Šæ¢æ±‚ãƒ¢ãƒ¼ãƒ‰ï¼šå„ãƒˆãƒ”ãƒƒã‚¯4ã€œ6å›ç¨‹åº¦ã®ã‚„ã‚Šå–ã‚Šã‚’ç›®å®‰ã«ã€ã—ã£ã‹ã‚Šæ·±æ˜ã‚Šã—ã¦ãã ã•ã„ï¼‰"
                : "ï¼ˆæ¨™æº–ãƒ¢ãƒ¼ãƒ‰ï¼šå„ãƒˆãƒ”ãƒƒã‚¯2ã€œ4å›ç¨‹åº¦ã®ã‚„ã‚Šå–ã‚Šã‚’ç›®å®‰ã«ã€ãƒ†ãƒ³ãƒã‚ˆãé€²ã‚ã¦ãã ã•ã„ï¼‰";
            situationInstruction = `
## ç¾åœ¨ã®çŠ¶æ³
- ç¾åœ¨ã®ãƒˆãƒ”ãƒƒã‚¯: ã€Œ${currentTopic}ã€
- æ®‹ã‚Šãƒˆãƒ”ãƒƒã‚¯æ•°: ${remainingCount}å€‹${isLastTopic ? 'ï¼ˆã“ã‚ŒãŒæœ€å¾Œã®ãƒˆãƒ”ãƒƒã‚¯ï¼‰' : ''}
- ã‚¤ãƒ³ã‚¿ãƒ“ãƒ¥ãƒ¼ã‚¹ã‚¿ã‚¤ãƒ«: ${depthHint}

## ãƒˆãƒ”ãƒƒã‚¯ä¸€è¦§
${topicsList}`;
        }

        return `
# Persona
${CONFIG.persona}
${contextText}
${situationInstruction}

# ã‚¤ãƒ³ã‚¿ãƒ“ãƒ¥ãƒ¼é€²è¡Œãƒ«ãƒ¼ãƒ«

## å¯¾è©±ã®è³ªã«å¿œã˜ãŸå¯¾å¿œï¼ˆé‡è¦ï¼ï¼‰

### å›ç­”ãŒçŸ­ã„ãƒ»ã‚ã£ã•ã‚Šã—ã¦ã„ã‚‹å ´åˆ
ä»¥ä¸‹ã®ã„ãšã‚Œã‹ã§**ã‚‚ã†å°‘ã—å¼•ãå‡ºã—ã¦**ãã ã•ã„ï¼š
- ã€Œã‚‚ã†å°‘ã—è©³ã—ãèã‹ã›ã¦ã‚‚ã‚‰ãˆã¾ã™ã‹ï¼Ÿã€
- ã€Œãã‚Œã£ã¦å…·ä½“çš„ã«ã¯ã©ã†ã„ã†ã“ã¨ã§ã™ã‹ï¼Ÿã€
- ã€Œä¾‹ãˆã°ã©ã‚“ãªå ´é¢ã§ãã†æ„Ÿã˜ã¾ã—ãŸã‹ï¼Ÿã€
- ã€Œã€œã¨ã„ã†ç†è§£ã§åˆã£ã¦ã¾ã™ã‹ï¼Ÿã€ã¨åˆ¥ã®è¨€è‘‰ã§ç¢ºèª
- æ¯”å–©ã‚„ä¾‹ãˆè©±ã§ã€Œã¤ã¾ã‚Šã€œã¿ãŸã„ãªæ„Ÿã˜ã§ã™ã‹ï¼Ÿã€

### å›ç­”ãŒæ›–æ˜§ãƒ»æŠ½è±¡çš„ãªå ´åˆ
- ã€Œä¸€ç•ªå°è±¡ã«æ®‹ã£ã¦ã„ã‚‹ã‚¨ãƒ”ã‚½ãƒ¼ãƒ‰ã‚’æ•™ãˆã¦ãã ã•ã„ã€
- ã€Œæ™‚ç³»åˆ—ã§è¨€ã†ã¨ã€æœ€åˆã«ä½•ãŒèµ·ãã¾ã—ãŸã‹ï¼Ÿã€
- ã€Œæ•°å­—ã§è¨€ã†ã¨ã©ã®ãã‚‰ã„ã§ã™ã‹ï¼Ÿã€

### å›ç­”ãŒå……å®Ÿã—ã¦ã„ã‚‹ãƒ»ç››ã‚Šä¸ŠãŒã£ã¦ã„ã‚‹å ´åˆ
ã©ã‚“ã©ã‚“æ·±æ˜ã‚Šã—ã¦ãã ã•ã„ï¼š
- æ„Ÿæƒ…ã‚’æ˜ã‚‹ï¼šã€Œãã®æ™‚ã©ã‚“ãªæ°—æŒã¡ã§ã—ãŸã‹ï¼Ÿã€
- ç†ç”±ã‚’æ˜ã‚‹ï¼šã€Œãªãœãã†æ€ã£ãŸã‚“ã§ã™ã‹ï¼Ÿã€
- å½±éŸ¿ã‚’æ˜ã‚‹ï¼šã€Œãã‚ŒãŒä»Šã«ã©ã†ç¹‹ãŒã£ã¦ã„ã¾ã™ã‹ï¼Ÿã€
- æ„å¤–ãªè§’åº¦ï¼šã€Œé€†ã«ã€œã ã£ãŸã‚‰ã©ã†ã§ã—ãŸã‹ï¼Ÿã€

### æ¬¡ã®ãƒˆãƒ”ãƒƒã‚¯ã«ç§»ã‚‹ã‚¿ã‚¤ãƒŸãƒ³ã‚°
ä»¥ä¸‹ã®å ´åˆã«æ¬¡ã¸é€²ã‚“ã§ãã ã•ã„ï¼š
- åŒã˜è©±ãŒç¹°ã‚Šè¿”ã•ã‚Œã¦ã„ã‚‹
- ç›¸æ‰‹ãŒã€Œç‰¹ã«ãªã„ã§ã™ã€ã€Œãã®ãã‚‰ã„ã§ã™ã‹ã­ã€ã¨è¨€ã£ãŸ
- ååˆ†ãªæ·±ã•ï¼ˆç†ç”±ã€ã‚¨ãƒ”ã‚½ãƒ¼ãƒ‰ã€æ„Ÿæƒ…ï¼‰ãŒèã‘ãŸ
- 3å›ä»¥ä¸Šæ·±æ˜ã‚Šã—ã¦ã‚‚æ–°ã—ã„æƒ…å ±ãŒå‡ºãªã„

## ãƒˆãƒ”ãƒƒã‚¯ç§»è¡Œã®æ–¹æ³•
æ¬¡ã®ãƒˆãƒ”ãƒƒã‚¯ã«ç§»ã‚‹æ™‚ã¯ã€å›ç­”ã®**æœ«å°¾**ã«å¿…ãš \`[[NEXT]]\` ã‚’ä»˜ã‘ã¦ãã ã•ã„ã€‚
ä¾‹: ã€Œãªã‚‹ã»ã©ã€ã‚ˆãåˆ†ã‹ã‚Šã¾ã—ãŸã€‚ã§ã¯æ¬¡ã«ã€ã€œã«ã¤ã„ã¦ãŠèãã—ãŸã„ã®ã§ã™ãŒ...ï¼Ÿ[[NEXT]]ã€

## åŸºæœ¬ãƒ«ãƒ¼ãƒ«
1. **ã‚ªã‚¦ãƒ è¿”ã—ç¦æ­¢** - ã€Œã€œã¨ã„ã†ã“ã¨ã§ã™ã­ã€ã€Œã€œãªã‚“ã§ã™ã­ã€ã¯ä½¿ã‚ãªã„
2. **ç›¸æ§Œã‹ã‚‰å§‹ã‚ã‚‹** - ã€Œãªã‚‹ã»ã©ã€ã€ã€Œã¸ã‡ã€œã€ã€ã€Œã‚ãã€ã€ãªã©ï¼ˆæ¯å›é•ã†ã‚‚ã®ã‚’ï¼‰
3. **ã™ãè³ªå•** - é•·ã„å‰ç½®ããªã—ã§è³ªå•ã¸
4. **å¿…ãšè³ªå•ã§çµ‚ã‚ã‚‹** - ç™ºè¨€ã®æœ€å¾Œã¯è³ªå•å½¢
5. **çµ‚äº†ç¦æ­¢** - çµ‚äº†ã™ã‚‹æ™‚ä»¥å¤–ã¯ã€Œçµ‚äº†ã—ã¾ã™ã€ã¨è¨€ã‚ãªã„
`;
    }

    // --- API Call (Token optimization) ---
    async function callGroqAPI(history, systemPrompt, customTemp = 0.7, customMaxTokens = 1024, callType = 'interview') {
        const url = "https://api.groq.com/openai/v1/chat/completions";

        // â˜…ãƒˆãƒ¼ã‚¯ãƒ³ç¯€ç´„ãƒ­ã‚¸ãƒƒã‚¯: å±¥æ­´ã¯ç›´è¿‘ã®10ä»¶ï¼ˆ5å¾€å¾©ï¼‰ã®ã¿é€ä¿¡ã™ã‚‹
        const MAX_HISTORY = 10;
        const recentHistory = history.length > MAX_HISTORY ? history.slice(-MAX_HISTORY) : history;

        const messages = [{ role: "system", content: systemPrompt }, ...recentHistory];

        const payload = {
            model: CONFIG.modelName || "llama-3.1-8b-instant",
            messages: messages,
            temperature: customTemp,
            max_tokens: customMaxTokens
        };

        // ãƒ‡ãƒãƒƒã‚°: ãƒªã‚¯ã‚¨ã‚¹ãƒˆé€ä¿¡å‰ã«è¨˜éŒ²
        addDebugEntry(`${callType} - Sending Request`, systemPrompt, messages);
        console.log('[DEBUG] API Request starting...', { model: payload.model, messageCount: messages.length });

        // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆä»˜ãfetchï¼ˆ30ç§’ï¼‰
        const controller = new AbortController();
        const timeoutId = setTimeout(() => {
            controller.abort();
            console.log('[DEBUG] API Request timeout after 30s');
        }, 30000);

        try {
            const response = await fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${CONFIG.apiKey}`
                },
                body: JSON.stringify(payload),
                signal: controller.signal
            });

            clearTimeout(timeoutId);
            console.log('[DEBUG] API Response received, status:', response.status);

            if (!response.ok) {
                const err = await response.json().catch(() => ({}));
                // Rate Limitã‚¨ãƒ©ãƒ¼ã®å ´åˆã¯ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«åˆ†ã‹ã‚Šã‚„ã™ãè¡¨ç¤º
                if (response.status === 429) {
                    throw new Error("Rate Limit Exceeded: 1æ—¥ã®åˆ©ç”¨åˆ¶é™ã«é”ã—ã¾ã—ãŸã€‚æ™‚é–“ã‚’ãŠã„ã¦è©¦ã—ã¦ãã ã•ã„ã€‚");
                }
                throw new Error(`Groq API Error: ${err.error?.message || response.statusText}`);
            }

            const data = await response.json();
            console.log('[DEBUG] API Response parsed successfully');
            const responseText = data.choices[0].message.content;

            // ãƒ‡ãƒãƒƒã‚°: ãƒ¬ã‚¹ãƒãƒ³ã‚¹å—ä¿¡å¾Œã«è¨˜éŒ²ã‚’æ›´æ–°
            if (promptLog.length > 0) {
                promptLog[promptLog.length - 1].response = responseText;
                promptLog[promptLog.length - 1].status = `${callType} - Response Received`;
            }

            // ãƒ‡ãƒãƒƒã‚°ç”»é¢ã‚‚æ›´æ–°
            updateDebugEntryResponse(responseText);

            return responseText;
        } catch (err) {
            clearTimeout(timeoutId);
            if (err.name === 'AbortError') {
                throw new Error('APIå‘¼ã³å‡ºã—ãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸï¼ˆ30ç§’ï¼‰ã€‚å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚');
            }
            throw err;
        }
    }

    async function generateSummary() {
        const summarySection = document.getElementById('summary-section');
        summarySection.style.display = 'block';
        const summaryBox = document.getElementById('summary-box');
        summaryBox.innerText = "é•·æ–‡ã‚µãƒãƒªãƒ¼ç”Ÿæˆä¸­...";

        const historyText = conversationHistory.map(item => `${item.role}: ${item.content}`).join("\n");
        const prompt = `ä»¥ä¸‹ã®ãƒ­ã‚°ã‚’å…ƒã«ã€è©³ç´°ãªãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ã‚¿ãƒªãƒ¼è¨˜äº‹ã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚\n\nã€ãƒ­ã‚°ã€‘\n${historyText}`;
        
        try {
            // ã‚µãƒãƒªãƒ¼ç”Ÿæˆæ™‚ã¯å±¥æ­´ã‚’é€ã‚‰ãšã€ãƒ†ã‚­ã‚¹ãƒˆåŒ–ã—ã¦é€ã‚‹ï¼ˆã“ã‚Œã¯å¤‰ãˆãªã„ï¼‰
            // Summaryæ™‚ã¯ãƒˆãƒ¼ã‚¯ãƒ³æ¶ˆè²»ãŒå¤šã„ãŒ1å›ã ã‘ãªã®ã§è¨±å®¹ã™ã‚‹ã€‚
            const summaryText = await callGroqAPI([{ role: "user", content: prompt }], "ã‚ãªãŸã¯å„ªç§€ãªãƒ©ã‚¤ã‚¿ãƒ¼ã§ã™ã€‚", 0.7, 4096, 'summary');
            summaryBox.innerText = summaryText;
            updateStatus('idle', 'å®Œäº†');
            setButtonState("FINISHED");
            // ã‚µãƒãƒªãƒ¼å®Œäº†å¾Œã«ãƒœã‚¿ãƒ³ã‚’æœ‰åŠ¹åŒ–
            document.getElementById('copy-btn').disabled = false;
            document.getElementById('back-btn').disabled = false;
            await saveToDB(summaryText);
        } catch (error) {
            summaryBox.innerHTML = `<span style="color:red;">${error.message}</span>`;
            updateStatus('error', 'ã‚¨ãƒ©ãƒ¼');
            // ã‚¨ãƒ©ãƒ¼æ™‚ã‚‚æˆ»ã‚‹ãƒœã‚¿ãƒ³ã¯æœ‰åŠ¹åŒ–
            document.getElementById('back-btn').disabled = false;
            setButtonState("FINISHED");
        }
    }

    function openDB() {
        return new Promise((r, j) => {
            const req = indexedDB.open(DB_NAME, DB_VERSION);
            req.onupgradeneeded = (e) => { 
                const db = e.target.result; 
                if (!db.objectStoreNames.contains(STORE_NAME)) db.createObjectStore(STORE_NAME, { keyPath: "id" });
            };
            req.onsuccess = (e) => r(e.target.result);
            req.onerror = (e) => j(e.target.error);
        });
    }

    async function saveToDB(summaryText) {
        try {
            const db = await openDB();
            const tx = db.transaction(STORE_NAME, "readwrite");
            const store = tx.objectStore(STORE_NAME);
            const record = {
                id: Date.now(),
                title: CONFIG.title,
                date: new Date().toLocaleString(),
                topics: CONFIG.topics,
                history: conversationHistory,
                summary: summaryText,
                // ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆå±¥æ­´ã‚’ä¿å­˜ï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
                promptLog: promptLog,
                // è¨­å®šæƒ…å ±ã‚‚ä¿å­˜
                settings: {
                    modelName: CONFIG.modelName || "llama-3.1-8b-instant",
                    context: CONFIG.context || "",
                    personaType: CONFIG.personaType || "listener",
                    persona: CONFIG.persona || "",
                    voiceName: CONFIG.voiceName || "",
                    rate: CONFIG.rate || 1.3,
                    depth: CONFIG.depth || "standard",
                    sttMode: CONFIG.sttMode || "groq"
                }
            };
            store.add(record);
        } catch (e) { console.error("DB Error:", e); }
    }

    function copySummary() {
        const text = document.getElementById('summary-box').innerText;
        navigator.clipboard.writeText(text).then(() => alert("ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸï¼"));
    }

    function cleanTextForSpeech(text) { return text.replace(/[\*#_`~]/g, ''); }

    function configureUtterance(utterance) {
        utterance.rate = CONFIG.rate; utterance.volume = 1.0; utterance.pitch = 1.0; 
        if (availableVoices.length === 0) availableVoices = window.speechSynthesis.getVoices();
        const selectedVoice = availableVoices.find(v => v.name === CONFIG.voiceName);
        if (selectedVoice) utterance.voice = selectedVoice;
    }
    
    // --- STT Engine (Groq Whisper / Web Speech API) ---

    let sttMode = 'groq'; // 'groq' or 'webspeech' â€” set from CONFIG
    let recognition = null; // Web Speech API instance
    let mediaRecorder = null;
    let audioChunks = [];
    let audioStream = null;
    let silenceCheckInterval = null;
    let speechDetected = false;
    let silenceStartTime = 0;
    let recordingStartTime = 0;
    let isListening = false;
    let interviewRunning = false;
    let consecutiveSilenceCount = 0;
    const SILENCE_THRESHOLD = 5;
    const SILENCE_DURATION = 2000;
    const MAX_RECORD_DURATION = 30000;
    const MAX_SILENCE_ROUNDS = 3;

    // --- èª­ã¿ä¸Šã’ä¸­ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼éŸ³å£°å‰²ã‚Šè¾¼ã¿æ¤œå‡º ---
    let speechInterruptionInterval = null;
    let userSpeechStartTime = 0;
    const INTERRUPT_RMS_THRESHOLD = 10;  // AIèª­ã¿ä¸Šã’ä¸­ã®æ¤œå‡ºé–¾å€¤ï¼ˆé€šå¸¸ã‚ˆã‚Šé«˜ã‚ï¼‰
    const INTERRUPT_DURATION = 1000;     // 1ç§’é–“ã®ç¶™ç¶šéŸ³å£°ã§å‰²ã‚Šè¾¼ã¿

    function startSpeechInterruptionDetection() {
        stopSpeechInterruptionDetection();
        userSpeechStartTime = 0;

        speechInterruptionInterval = setInterval(() => {
            if (!analyser || !isInterviewerSpeaking) {
                stopSpeechInterruptionDetection();
                return;
            }

            analyser.getByteTimeDomainData(dataArray);
            let sum = 0;
            for (let i = 0; i < dataArray.length; i++) {
                const v = (dataArray[i] - 128) / 128;
                sum += v * v;
            }
            const rms = Math.sqrt(sum / dataArray.length) * 100;

            if (rms > INTERRUPT_RMS_THRESHOLD) {
                if (userSpeechStartTime === 0) {
                    userSpeechStartTime = Date.now();
                } else if (Date.now() - userSpeechStartTime > INTERRUPT_DURATION) {
                    console.log('[STT] User voice detected during AI speech, interrupting (RMS:', rms.toFixed(1), ')');
                    stopSpeechInterruptionDetection();
                    synth.cancel();
                    isInterviewerSpeaking = false;
                    isThinking = false;
                    document.getElementById('skip-btn').style.display = 'none';
                    startListening();
                }
            } else {
                userSpeechStartTime = 0;
            }
        }, 100);
    }

    function stopSpeechInterruptionDetection() {
        if (speechInterruptionInterval) {
            clearInterval(speechInterruptionInterval);
            speechInterruptionInterval = null;
        }
        userSpeechStartTime = 0;
    }

    function isHallucination(text) {
        if (!text || !text.trim()) return true;
        const t = text.trim();
        // 3æ–‡å­—ä»¥ä¸‹ã¯ç„¡è¦–
        if (t.length <= 3) return true;
        // åŒã˜æ–‡å­—ã®ç¹°ã‚Šè¿”ã—ï¼ˆã­ã‡ã­ã‡ã­ã‡...ã€ã‚ã‚ã‚ã‚...ç­‰ï¼‰
        // 2-4æ–‡å­—ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒå…¨ä½“ã®60%ä»¥ä¸Šã‚’å ã‚ãŸã‚‰ãƒãƒ«ã‚·ãƒãƒ¼ã‚·ãƒ§ãƒ³
        for (let len = 1; len <= 4; len++) {
            const pat = t.substring(0, len);
            const repeated = pat.repeat(Math.ceil(t.length / len)).substring(0, t.length);
            const matchCount = [...t].filter((c, i) => c === repeated[i]).length;
            if (matchCount / t.length > 0.6) {
                console.log('[STT] Hallucination detected (repeat):', t.substring(0, 30));
                return true;
            }
        }
        // ãƒ¦ãƒ‹ãƒ¼ã‚¯æ–‡å­—ãŒæ¥µç«¯ã«å°‘ãªã„ï¼ˆå…¨ä½“ã®10%ä»¥ä¸‹ï¼‰
        const unique = new Set(t.replace(/\s/g, '')).size;
        if (unique <= 2 && t.length > 5) {
            console.log('[STT] Hallucination detected (low unique):', t.substring(0, 30));
            return true;
        }
        return false;
    }

    function getRecorderMimeType() {
        const types = ['audio/webm;codecs=opus', 'audio/webm', 'audio/mp4', 'audio/ogg;codecs=opus'];
        for (const type of types) {
            if (MediaRecorder.isTypeSupported(type)) return type;
        }
        return '';
    }

    function startListening() {
        if (isListening || !interviewRunning) return;
        if (sttMode === 'webspeech') {
            startListeningWebSpeech();
        } else {
            startListeningGroq();
        }
    }

    function startListeningGroq() {
        if (isListening || !audioStream) return;
        isListening = true;
        audioChunks = [];
        speechDetected = false;
        silenceStartTime = 0;
        recordingStartTime = Date.now();

        updateStatus('listening', 'èã„ã¦ã„ã¾ã™...');
        toggleVisualizer(true);
        console.log('[STT] startListeningGroq');

        const mimeType = getRecorderMimeType();
        const options = mimeType ? { mimeType } : {};
        mediaRecorder = new MediaRecorder(audioStream, options);

        mediaRecorder.ondataavailable = (e) => {
            if (e.data.size > 0) audioChunks.push(e.data);
        };

        mediaRecorder.onstop = async () => {
            console.log('[STT] MediaRecorder stopped, chunks:', audioChunks.length, 'forceReply:', forceReplyMode);
            const wasForceReply = forceReplyMode;
            forceReplyMode = false;

            if (audioChunks.length === 0 || !speechDetected) {
                if (wasForceReply) {
                    consecutiveSilenceCount = 0;
                    addMessage('user', '(ç¶šã‘ã¦ãã ã•ã„)');
                    processUserResponse('ç¶šã‘ã¦ãã ã•ã„');
                    return;
                }
                consecutiveSilenceCount++;
                console.log('[STT] No speech detected, silence count:', consecutiveSilenceCount);
                if (consecutiveSilenceCount >= MAX_SILENCE_ROUNDS) {
                    handleSilenceTimeout();
                    return;
                }
                if (!isInterviewerSpeaking && !isThinking) {
                    startListening();
                }
                return;
            }
            const blob = new Blob(audioChunks, { type: mimeType || 'audio/webm' });
            updateStatus('thinking', 'éŸ³å£°ã‚’èªè­˜ä¸­ (Groq Whisper)...');
            toggleVisualizer(false);
            try {
                const text = await transcribeGroq(blob);
                console.log('[STT] Transcribed:', text);
                if (isHallucination(text)) {
                    consecutiveSilenceCount++;
                    console.log('[STT] Hallucination filtered, silence count:', consecutiveSilenceCount);
                    if (consecutiveSilenceCount >= MAX_SILENCE_ROUNDS) {
                        handleSilenceTimeout();
                        return;
                    }
                    if (!isInterviewerSpeaking && !isThinking) {
                        startListening();
                    }
                    return;
                }
                consecutiveSilenceCount = 0;
                if (text && text.trim() && !isInterviewerSpeaking && !isThinking) {
                    addMessage('user', text.trim());
                    processUserResponse(text.trim());
                } else if (wasForceReply) {
                    addMessage('user', '(ç¶šã‘ã¦ãã ã•ã„)');
                    processUserResponse('ç¶šã‘ã¦ãã ã•ã„');
                } else {
                    startListening();
                }
            } catch (e) {
                console.error('[STT] Transcription error:', e);
                updateStatus('error', 'éŸ³å£°èªè­˜ã‚¨ãƒ©ãƒ¼: ' + e.message);
                setTimeout(() => startListening(), 1000);
            }
        };

        mediaRecorder.start(250);
        startSilenceDetection();
    }

    function stopListening() {
        if (sttMode === 'webspeech') {
            stopListeningWebSpeech();
        } else {
            stopListeningGroq();
        }
    }

    function stopListeningGroq() {
        isListening = false;
        if (silenceCheckInterval) {
            clearInterval(silenceCheckInterval);
            silenceCheckInterval = null;
        }
        if (mediaRecorder && mediaRecorder.state !== 'inactive') {
            try { mediaRecorder.stop(); } catch(e) {}
        }
        toggleVisualizer(false);
        console.log('[STT] stopListeningGroq');
    }

    // --- Web Speech API ---

    function startListeningWebSpeech() {
        if (isListening) return;
        isListening = true;

        updateStatus('listening', 'èã„ã¦ã„ã¾ã™...');
        toggleVisualizer(true);
        console.log('[STT] startListeningWebSpeech');

        if (!recognition) {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (!SpeechRecognition) {
                updateStatus('error', 'Web Speech APIãŒã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã§ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã›ã‚“');
                isListening = false;
                return;
            }
            recognition = new SpeechRecognition();
            recognition.lang = 'ja-JP';
            recognition.continuous = false;
            recognition.interimResults = false;
        }

        recognition.onresult = (event) => {
            const text = event.results[event.results.length - 1][0].transcript;
            console.log('[STT] Web Speech result:', text);
            isListening = false;
            toggleVisualizer(false);

            if (isHallucination(text)) {
                consecutiveSilenceCount++;
                if (consecutiveSilenceCount >= MAX_SILENCE_ROUNDS) {
                    handleSilenceTimeout();
                    return;
                }
                if (!isInterviewerSpeaking && !isThinking) startListening();
                return;
            }

            consecutiveSilenceCount = 0;
            if (text && text.trim() && !isInterviewerSpeaking && !isThinking) {
                addMessage('user', text.trim());
                processUserResponse(text.trim());
            } else {
                startListening();
            }
        };

        recognition.onerror = (event) => {
            console.error('[STT] Web Speech error:', event.error);
            isListening = false;

            if (event.error === 'no-speech') {
                consecutiveSilenceCount++;
                if (consecutiveSilenceCount >= MAX_SILENCE_ROUNDS) {
                    handleSilenceTimeout();
                    return;
                }
                if (interviewRunning && !isInterviewerSpeaking && !isThinking) {
                    setTimeout(() => startListening(), 300);
                }
                return;
            }

            if (event.error === 'network') {
                updateStatus('error', 'ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼ã€‚è¨­å®šç”»é¢ã§Groq Whisperã¸ã®åˆ‡ã‚Šæ›¿ãˆã‚’æ¨å¥¨ã—ã¾ã™ã€‚');
                return;
            }

            if (event.error === 'aborted' || event.error === 'not-allowed') return;

            updateStatus('error', 'éŸ³å£°èªè­˜ã‚¨ãƒ©ãƒ¼: ' + event.error);
            if (interviewRunning) setTimeout(() => startListening(), 1000);
        };

        recognition.onend = () => {
            console.log('[STT] Web Speech onend, isListening:', isListening);
            if (isListening && interviewRunning && !isInterviewerSpeaking && !isThinking) {
                // å°‘ã—å¾…ã£ã¦ã‹ã‚‰ãƒªã‚¹ã‚¿ãƒ¼ãƒˆï¼ˆå‰ã®ã‚»ãƒƒã‚·ãƒ§ãƒ³å®Œäº†ã‚’ç¢ºå®Ÿã«ã™ã‚‹ï¼‰
                setTimeout(() => {
                    if (isListening && interviewRunning && !isInterviewerSpeaking && !isThinking) {
                        try { recognition.start(); } catch(e) {
                            console.warn('[STT] Web Speech restart failed:', e.message);
                            isListening = false;
                            setTimeout(() => startListening(), 300);
                        }
                    }
                }, 100);
            }
        };

        try {
            // æ—¢å­˜ã‚»ãƒƒã‚·ãƒ§ãƒ³ãŒæ®‹ã£ã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ã®ã§abortã—ã¦ã‹ã‚‰é–‹å§‹
            try { recognition.abort(); } catch(e2) {}
            setTimeout(() => {
                try {
                    recognition.start();
                } catch (e) {
                    console.error('[STT] Web Speech start error:', e);
                    isListening = false;
                    // ãƒªãƒˆãƒ©ã‚¤
                    if (interviewRunning && !isInterviewerSpeaking && !isThinking) {
                        setTimeout(() => startListening(), 500);
                    }
                }
            }, 100);
        } catch (e) {
            console.error('[STT] Web Speech abort error:', e);
            isListening = false;
        }
    }

    function stopListeningWebSpeech() {
        isListening = false;
        if (recognition) {
            try { recognition.stop(); } catch(e) {}
        }
        toggleVisualizer(false);
        console.log('[STT] stopListeningWebSpeech');
    }

    function startSilenceDetection() {
        if (silenceCheckInterval) clearInterval(silenceCheckInterval);
        silenceCheckInterval = setInterval(() => {
            if (!analyser || !isListening) return;

            analyser.getByteTimeDomainData(dataArray);
            let sum = 0;
            for (let i = 0; i < dataArray.length; i++) {
                const v = (dataArray[i] - 128) / 128;
                sum += v * v;
            }
            const rms = Math.sqrt(sum / dataArray.length) * 100;

            if (rms > SILENCE_THRESHOLD) {
                speechDetected = true;
                silenceStartTime = 0;
            } else if (speechDetected) {
                if (silenceStartTime === 0) {
                    silenceStartTime = Date.now();
                } else if (Date.now() - silenceStartTime > SILENCE_DURATION) {
                    console.log('[STT] Silence detected, stopping recording');
                    stopListening();
                    return;
                }
            }

            if (Date.now() - recordingStartTime > MAX_RECORD_DURATION) {
                console.log('[STT] Max duration reached, stopping recording');
                stopListening();
            }
        }, 100);
    }

    async function transcribeGroq(audioBlob) {
        const mimeType = audioBlob.type || 'audio/webm';
        const ext = mimeType.includes('mp4') ? 'mp4' : mimeType.includes('ogg') ? 'ogg' : 'webm';

        const formData = new FormData();
        formData.append('file', audioBlob, `audio.${ext}`);
        formData.append('model', 'whisper-large-v3-turbo');
        formData.append('language', 'ja');
        formData.append('response_format', 'json');

        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 15000);

        try {
            const response = await fetch('https://api.groq.com/openai/v1/audio/transcriptions', {
                method: 'POST',
                headers: { 'Authorization': `Bearer ${CONFIG.apiKey}` },
                body: formData,
                signal: controller.signal
            });
            clearTimeout(timeoutId);

            if (!response.ok) {
                const err = await response.json().catch(() => ({}));
                throw new Error(`Whisper API Error: ${err.error?.message || response.statusText}`);
            }

            const data = await response.json();
            console.log('[STT] Groq Whisper result:', data.text);
            return data.text;
        } catch (err) {
            clearTimeout(timeoutId);
            if (err.name === 'AbortError') throw new Error('éŸ³å£°èªè­˜ãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸ');
            throw err;
        }
    }

    function handleSilenceTimeout() {
        if (!interviewRunning) return;
        console.log('[STT] Silence timeout - asking user');
        consecutiveSilenceCount = 0;
        updateStatus('idle', 'ç„¡éŸ³ãŒç¶šã„ã¦ã„ã¾ã™');
        toggleVisualizer(false);
        const msg = 'ã—ã°ã‚‰ãéŸ³å£°ãŒæ¤œå‡ºã•ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚ã‚¤ãƒ³ã‚¿ãƒ“ãƒ¥ãƒ¼ã‚’çµ‚äº†ã—ã¾ã™ã‹ï¼Ÿ';
        addMessage('ai', msg);
        speak(msg, () => {
            // ç™ºè©±å¾Œã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å¿œç­”ã‚’å¾…ã¤ï¼ˆstartListeningã¯ speak() ã® onend ã§å‘¼ã°ã‚Œã‚‹ï¼‰
            // â†’ speak ã® onComplete ã‚’æŒ‡å®šã—ã¦ã„ã‚‹ã®ã§ã€è‡ªå‹•çš„ã«ã¯ startListening ã—ãªã„
            // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã€Œè¿”ä¿¡ã—ã¦ã€ã‚„ãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ›ã§å¿œç­”ã™ã‚‹ã®ã‚’å¾…ã¤
            updateStatus('listening', 'èã„ã¦ã„ã¾ã™...');
            toggleVisualizer(true);
            // çŸ­ã„å¾…æ©Ÿå¾Œã«ãƒªã‚¹ãƒ‹ãƒ³ã‚°é–‹å§‹
            setTimeout(() => startListening(), 500);
        });
    }

    // --- ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œãƒœã‚¿ãƒ³ ---

    let forceReplyMode = false;

    async function forceReply() {
        if (!isListening && !isInterviewerSpeaking && !isThinking) return;
        console.log('[UI] forceReply called');

        // èª­ã¿ä¸Šã’ä¸­ãªã‚‰ä¸­æ­¢
        if (synth.speaking || synth.pending) {
            synth.cancel();
            isInterviewerSpeaking = false;
            document.getElementById('skip-btn').style.display = 'none';
        }
        stopSpeechInterruptionDetection();

        if (isListening) {
            if (sttMode === 'webspeech') {
                // Web Speech API: åœæ­¢ã—ã¦ç›´æ¥AIã«ä¾é ¼
                stopListening();
                addMessage('user', '(ç¶šã‘ã¦ãã ã•ã„)');
                processUserResponse('ç¶šã‘ã¦ãã ã•ã„');
                return;
            }
            // Groq mode: forceReplyModeãƒ•ãƒ©ã‚°ã§onstopãƒãƒ³ãƒ‰ãƒ©ã«åˆ¶å¾¡ã‚’å§”è­²
            forceReplyMode = true;
            stopListening();
            return;
        }

        // è´è¬›ä¸­ã§ãªã‘ã‚Œã°ç›´æ¥AIã«ç¶šè¡Œã‚’ä¾é ¼
        addMessage('user', '(ç¶šã‘ã¦ãã ã•ã„)');
        processUserResponse('ç¶šã‘ã¦ãã ã•ã„');
    }

    function sendTextInput() {
        const input = document.getElementById('text-input');
        const text = input.value.trim();
        if (!text) return;
        input.value = '';

        console.log('[UI] sendTextInput:', text);
        // èª­ã¿ä¸Šã’ä¸­ãªã‚‰ä¸­æ­¢
        if (synth.speaking || synth.pending) {
            synth.cancel();
            isInterviewerSpeaking = false;
            isThinking = false;
            document.getElementById('skip-btn').style.display = 'none';
        }
        stopSpeechInterruptionDetection();
        stopListening();
        addMessage('user', text);
        processUserResponse(text);
    }

    function requestNextTopic() {
        console.log('[UI] requestNextTopic');
        // èª­ã¿ä¸Šã’ä¸­ãªã‚‰ä¸­æ­¢
        if (synth.speaking || synth.pending) {
            synth.cancel();
            isInterviewerSpeaking = false;
            isThinking = false;
            document.getElementById('skip-btn').style.display = 'none';
        }
        stopSpeechInterruptionDetection();
        stopListening();
        addMessage('user', '(æ¬¡ã®è©±é¡Œã¸)');
        processUserResponse('æ¬¡ã®è©±é¡Œã«ç§»ã£ã¦ãã ã•ã„');
    }

    function speak(text, onComplete = null) {
        const cleanText = cleanTextForSpeech(text);
        isInterviewerSpeaking = true;
        updateStatus('speaking', 'AIãŒè©±ã—ã¦ã„ã¾ã™...');
        console.log('[DEBUG] speak() called, text length:', cleanText.length);

        const skipBtn = document.getElementById('skip-btn');
        if (skipBtn) skipBtn.style.display = 'inline-block';

        const utterance = new SpeechSynthesisUtterance(cleanText);
        configureUtterance(utterance);

        // èª­ã¿ä¸Šã’ä¸­ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼éŸ³å£°å‰²ã‚Šè¾¼ã¿æ¤œå‡ºã‚’é–‹å§‹
        if (analyser && interviewRunning && !onComplete) {
            startSpeechInterruptionDetection();
        }

        utterance.onend = () => {
            console.log('[DEBUG] utterance.onend fired, synth.pending:', synth.pending, 'isListening:', isListening);
            stopSpeechInterruptionDetection();
            if(skipBtn) skipBtn.style.display = 'none';
            if (!synth.pending) {
                isInterviewerSpeaking = false;
                isThinking = false;
                if (onComplete) { onComplete(); return; }
                // isListeningãŒæ—¢ã«trueãªã‚‰ã€skipSpeechç­‰ã§æ—¢ã«startListeningãŒå‘¼ã°ã‚Œã¦ã„ã‚‹ã®ã§äºŒé‡å‘¼ã³å‡ºã—ã‚’é˜²ã
                if (!isListening && !document.querySelector('.status-error') && !document.querySelector('.status-finishing')){
                    startListening();
                }
            }
        };

        utterance.onerror = (e) => {
            // synth.cancel()ã«ã‚ˆã‚‹"interrupted"ã¯æ­£å¸¸å‹•ä½œãªã®ã§warnãƒ¬ãƒ™ãƒ«ã«
            if (e.error === 'interrupted') {
                console.log('[DEBUG] utterance interrupted (skip/cancel)');
            } else {
                console.error('[DEBUG] utterance.onerror:', e.error);
            }
            stopSpeechInterruptionDetection();
        };

        synth.speak(utterance);
        console.log('[DEBUG] synth.speak() called');
    }

    function setupVisualizerCanvas() {
        const canvas = document.getElementById("visualizer");
        canvasCtx = canvas.getContext("2d");
        canvasCtx.fillStyle = '#222'; canvasCtx.fillRect(0, 0, canvas.width, canvas.height);
    }
    async function initAudioContext() {
        if (audioContext) return;
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        audioStream = stream;
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const source = audioContext.createMediaStreamSource(stream);
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 2048; source.connect(analyser);
        dataArray = new Uint8Array(analyser.frequencyBinCount);
        drawVisualizer();
    }
    function drawVisualizer() {
        visualizerFrame = requestAnimationFrame(drawVisualizer);
        if (!analyser) return;
        analyser.getByteTimeDomainData(dataArray);
        const canvas = document.getElementById("visualizer");
        const width = canvas.width; const height = canvas.height;
        canvasCtx.fillStyle = '#222'; canvasCtx.fillRect(0, 0, width, height);
        canvasCtx.lineWidth = 2; canvasCtx.strokeStyle = '#00ffcc'; canvasCtx.beginPath();
        const sliceWidth = width * 1.0 / dataArray.length; let x = 0;
        for (let i = 0; i < dataArray.length; i++) {
            const v = dataArray[i] / 128.0; const y = v * height / 2;
            if (i === 0) canvasCtx.moveTo(x, y); else canvasCtx.lineTo(x, y);
            x += sliceWidth;
        }
        canvasCtx.lineTo(canvas.width, canvas.height / 2); canvasCtx.stroke();
    }
    function toggleVisualizer(isActive) { document.getElementById('visualizer-container').classList.toggle('inactive-visualizer', !isActive); }
    function updateStatus(state, text) {
        const el = document.getElementById('status'); el.className = 'status-box status-' + state; el.innerText = text;
    }
    function addMessage(role, text) {
        const log = document.getElementById('chat-log'); const div = document.createElement('div');
        div.className = `message role-${role}`; div.innerHTML = (role === 'ai' ? 'ğŸ¤– ' : 'ğŸ‘¤ ') + text;
        log.appendChild(div); log.scrollTop = log.scrollHeight;
    }

    // ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰é–¢é€£ã®é–¢æ•°
    function toggleDebugMode() {
        debugMode = document.getElementById('debug-mode-toggle').checked;
        const debugBox = document.getElementById('debug-box');
        debugBox.classList.toggle('active', debugMode);
    }

    function addDebugEntry(status, systemPrompt, messages, response = null) {
        try {
            const timestamp = new Date().toLocaleTimeString();
            const historyCount = messages.filter(m => m.role !== 'system').length;

            // promptLogã«è¨˜éŒ²ï¼ˆAIã®å¿œç­”ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã¨ç´ä»˜ã‘ï¼‰
            const logEntry = {
                timestamp: timestamp,
                status: status,
                systemPrompt: systemPrompt,
                messages: JSON.parse(JSON.stringify(messages)), // ãƒ‡ã‚£ãƒ¼ãƒ—ã‚³ãƒ”ãƒ¼
                response: response,
                aiResponseIndex: conversationHistory.filter(h => h.role === 'assistant').length
            };
            promptLog.push(logEntry);

            // ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰ãŒONã®å ´åˆã®ã¿ç”»é¢ã«è¡¨ç¤º
            if (!debugMode) return;

            const debugBox = document.getElementById('debug-box');
            const entry = document.createElement('div');
            entry.className = 'debug-entry';
            entry.id = `debug-entry-${promptLog.length - 1}`;

            // ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’çŸ­ç¸®è¡¨ç¤ºï¼ˆæœ€åˆã®500æ–‡å­—ï¼‰
            const shortPrompt = systemPrompt.length > 500
                ? systemPrompt.substring(0, 500) + '...(truncated)'
                : systemPrompt;

            // é€ä¿¡ã™ã‚‹ä¼šè©±å±¥æ­´ã‚’æ•´å½¢
            const historyMessages = messages.filter(m => m.role !== 'system');
            const historyHtml = historyMessages.map(m => {
                const roleLabel = m.role === 'user' ? 'ğŸ‘¤ User' : 'ğŸ¤– AI';
                const shortContent = m.content.length > 100 ? m.content.substring(0, 100) + '...' : m.content;
                return `<div style="margin: 3px 0; padding: 3px 6px; background: ${m.role === 'user' ? '#3a3a5a' : '#2a4a2a'}; border-radius: 3px;"><strong>${roleLabel}:</strong> ${escapeHtml(shortContent)}</div>`;
            }).join('');

            entry.innerHTML = `
                <div class="debug-timestamp">${timestamp}</div>
                <div class="debug-status">ğŸ“¡ ${status}</div>
                <div style="color: #aaa; margin-top: 8px;">System Prompt (ãƒˆãƒ”ãƒƒã‚¯çŠ¶æ³å«ã‚€):</div>
                <div class="debug-prompt">${escapeHtml(shortPrompt)}</div>
                <div style="color: #aaa; margin-top: 8px;">ğŸ“œ é€ä¿¡ã™ã‚‹ä¼šè©±å±¥æ­´ (${historyCount}ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸):</div>
                <div class="debug-prompt" style="color: #ff9; max-height: 120px;">${historyHtml || '<em>ãªã—</em>'}</div>
                <div class="debug-response-area"></div>
            `;

            debugBox.insertBefore(entry, debugBox.firstChild);

            // æœ€å¤§10ä»¶ã¾ã§ã«åˆ¶é™
            while (debugBox.children.length > 10) {
                debugBox.removeChild(debugBox.lastChild);
            }
        } catch (e) {
            console.error('Debug entry error:', e);
        }
    }

    function updateDebugEntryResponse(response) {
        try {
            if (!debugMode) return;

            const entryId = `debug-entry-${promptLog.length - 1}`;
            const entry = document.getElementById(entryId);
            if (entry) {
                const statusEl = entry.querySelector('.debug-status');
                if (statusEl) {
                    statusEl.innerHTML = 'âœ… Response Received';
                    statusEl.style.color = '#98fb98';
                }
                const responseArea = entry.querySelector('.debug-response-area');
                if (responseArea && response) {
                    responseArea.innerHTML = `
                        <div style="color: #aaa; margin-top: 8px;">Response:</div>
                        <div class="debug-prompt" style="color: #98fb98;">${escapeHtml(response.substring(0, 300))}${response.length > 300 ? '...' : ''}</div>
                    `;
                }
            }
        } catch (e) {
            console.error('Debug update error:', e);
        }
    }

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
</script>

</body>
</html>