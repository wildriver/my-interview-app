<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Interviewer (2026-02-09)</title>
    <style>
        body { font-family: "Helvetica Neue", Arial, sans-serif; max-width: 900px; margin: 0 auto; padding: 20px; background-color: #f0f2f5; color: #333; position: relative; }
        .container { background: white; padding: 30px; border-radius: 12px; box-shadow: 0 2px 10px rgba(0,0,0,0.05); }
        h2 { text-align: center; color: #2c3e50; margin-bottom: 5px; }
        .subtitle { text-align: center; color: #7f8c8d; font-size: 0.9em; margin-bottom: 20px; }
        
        #timer {
            position: absolute; top: 20px; right: 20px;
            font-size: 1.5em; font-weight: bold; color: #2c3e50;
            background: #fff; padding: 5px 15px; border-radius: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }

        .status-box { padding: 12px; margin-bottom: 10px; text-align: center; font-weight: bold; border-radius: 8px; transition: all 0.3s; }
        .status-idle { background-color: #e9ecef; color: #6c757d; }
        .status-listening { background-color: #ffebee; color: #c62828; border: 1px solid #ffcdd2; animation: pulse 2s infinite; }
        .status-thinking { background-color: #e3f2fd; color: #1565c0; border: 1px solid #bbdefb; }
        .status-speaking { background-color: #e8f5e9; color: #2e7d32; border: 1px solid #c8e6c9; }
        .status-finishing { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .status-error { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }

        #visualizer-container { height: 60px; background-color: #222; border-radius: 8px; margin-bottom: 20px; display: flex; overflow: hidden; }
        canvas { display: block; width: 100%; height: 100%; }
        .inactive-visualizer { opacity: 0.3; filter: grayscale(100%); }
        
        .content-wrapper { display: flex; gap: 20px; flex-wrap: wrap; }
        .chat-section { flex: 1; min-width: 300px; }
        .summary-section { flex: 1; min-width: 300px; display: none; }
        #chat-log { height: 400px; overflow-y: auto; border: 1px solid #eee; padding: 20px; background: #fafafa; border-radius: 8px; box-shadow: inset 0 1px 3px rgba(0,0,0,0.03); }
        
        .message { margin-bottom: 15px; padding: 12px 16px; border-radius: 12px; max-width: 90%; line-height: 1.5; }
        .role-user { background-color: #f55036; color: white; margin-left: auto; border-bottom-right-radius: 2px; }
        .role-ai { background-color: #fff; border: 1px solid #eee; margin-right: auto; border-bottom-left-radius: 2px; }
        
        #summary-box { height: 350px; overflow-y: auto; border: 1px solid #eee; padding: 20px; background: #fff; border-radius: 8px; line-height: 1.8; white-space: pre-wrap; margin-bottom: 10px; box-shadow: 0 1px 3px rgba(0,0,0,0.05); }
        .summary-title { font-weight: bold; color: #2c3e50; margin-bottom: 10px; border-left: 4px solid #f55036; padding-left: 10px; }

        /* --- „Éú„Çø„É≥„Ç®„É™„Ç¢„ÅÆ„Çπ„Çø„Ç§„É´ --- */
        .controls {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #eee;
        }

        /* ÂÖ±ÈÄö„Éú„Çø„É≥„Çπ„Çø„Ç§„É´ */
        .btn {
            padding: 14px 30px; font-size: 1em; font-weight: bold;
            cursor: pointer; border: none; border-radius: 50px;
            color: white; transition: all 0.2s; width: 100%;
        }
        .btn:hover { opacity: 0.9; transform: translateY(-1px); }
        .btn:active { transform: translateY(1px); }

        .btn-start { background-color: #f55036; max-width: 400px; display: block; margin: 0 auto; }
        .btn-start:hover { background-color: #d43f29; }
        .btn-abort { background-color: #95a5a6; }
        .btn-abort:hover { background-color: #7f8c8d; }
        .btn-finish { background-color: #f55036; }
        .btn-finish:hover { background-color: #d43f29; }
        .btn-back { background-color: #f55036; max-width: 400px; display: block; margin: 0 auto; }
        .btn-back:hover { background-color: #d43f29; }

        /* „Ç§„É≥„Çø„Éì„É•„ÉºÊìç‰Ωú„Ç®„É™„Ç¢ */
        .interview-actions {
            background: #fafafa;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            border: 1px solid #eee;
        }

        /* „Çπ„Ç≠„ÉÉ„Éó„ÉªËøî‰ø°„Éú„Çø„É≥Ë°å */
        #skip-btn-container {
            display: flex; justify-content: center; gap: 10px;
            margin-bottom: 12px; min-height: 36px;
        }
        #skip-btn {
            background-color: #6c757d; color: white; border: none;
            padding: 8px 20px; border-radius: 50px; font-weight: bold; font-size: 0.85em;
            cursor: pointer; display: none; transition: all 0.2s;
        }
        #skip-btn:hover { background-color: #5a6268; }
        #reply-btn {
            background-color: #e67e22; color: white; border: none;
            padding: 8px 20px; border-radius: 50px; font-weight: bold; font-size: 0.85em;
            cursor: pointer; display: inline-block; transition: all 0.2s;
        }
        #reply-btn:hover { background-color: #d35400; }

        /* „ÉÜ„Ç≠„Çπ„ÉàÂÖ•Âäõ */
        .text-input-row {
            display: flex; gap: 8px; max-width: 100%; margin: 0 auto 12px;
        }
        .text-input-row input {
            flex: 1; padding: 9px 14px; border: 1px solid #bdc3c7; border-radius: 50px;
            font-size: 0.95em; outline: none; transition: border-color 0.2s;
        }
        .text-input-row input:focus { border-color: #f55036; box-shadow: 0 0 0 2px rgba(245,80,54,0.1); }
        .text-input-row button {
            padding: 9px 18px; background-color: #f55036; color: white; border: none;
            border-radius: 50px; font-weight: bold; font-size: 0.85em; cursor: pointer;
            white-space: nowrap; transition: all 0.2s;
        }
        .text-input-row button:hover { background-color: #d43f29; }

        /* Ê¨°„ÅÆË©±È°å„Éú„Çø„É≥ */
        #next-topic-btn {
            background-color: #3498db; color: white; border: none;
            padding: 8px 20px; border-radius: 50px; font-weight: bold; font-size: 0.85em;
            cursor: pointer; display: inline-block; transition: all 0.2s;
        }
        #next-topic-btn:hover { background-color: #2980b9; }

        /* ÂÆüË°å‰∏≠„ÅÆ„É°„Ç§„É≥„Éú„Çø„É≥„Ç≥„É≥„ÉÜ„ÉäÔºàÊ®™‰∏¶„Å≥Ôºâ */
        .running-controls {
            display: flex; gap: 12px; justify-content: center;
            width: 100%; max-width: 500px; margin: 0 auto;
        }
        .running-controls button { flex: 1; font-size: 0.95em; padding: 12px 20px; }

        /* „Éì„É´„Éâ„Éê„Éº„Ç∏„Éß„É≥ */
        .build-version { text-align: right; font-size: 0.75em; color: #bdc3c7; margin-top: 10px; }

        .copy-btn { width: 100%; padding: 10px; background-color: #f55036; color: white; border: none; border-radius: 50px; cursor: pointer; font-weight: bold; transition: all 0.2s; }
        .copy-btn:hover { background-color: #d43f29; }
        .copy-btn:disabled, .btn-back:disabled { background-color: #bdc3c7; cursor: not-allowed; opacity: 0.7; }

        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.6; } 100% { opacity: 1; } }

        /* „Éá„Éê„ÉÉ„Ç∞„É¢„Éº„Éâ */
        .debug-toggle-container {
            display: flex;
            justify-content: flex-end;
            margin-top: 15px;
            padding-top: 10px;
        }
        .debug-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.85em;
            color: #7f8c8d;
            cursor: pointer;
        }
        .debug-toggle input[type="checkbox"] {
            width: 16px;
            height: 16px;
        }
        .debug-box {
            display: none;
            margin-top: 15px;
            padding: 15px;
            background: #1e1e1e;
            border-radius: 8px;
            color: #00ff00;
            font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
            font-size: 0.8em;
            max-height: 300px;
            overflow-y: auto;
        }
        .debug-box.active { display: block; }
        .debug-entry {
            margin-bottom: 12px;
            padding-bottom: 12px;
            border-bottom: 1px solid #333;
        }
        .debug-entry:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }
        .debug-timestamp {
            color: #888;
            font-size: 0.9em;
            margin-bottom: 4px;
        }
        .debug-status {
            color: #ffd700;
            font-weight: bold;
            margin-bottom: 4px;
        }
        .debug-prompt {
            white-space: pre-wrap;
            word-break: break-word;
            color: #7fdbff;
            max-height: 150px;
            overflow-y: auto;
            padding: 8px;
            background: #2a2a2a;
            border-radius: 4px;
            margin-top: 4px;
        }
        .debug-history {
            color: #ff6b6b;
            margin-top: 4px;
        }
    </style>
</head>
<body>

<div id="timer">00:00</div>

<div class="container">
    <h2 id="page-title" data-i18n="interview_title">„Ç§„É≥„Çø„Éì„É•„Éº</h2>
    <div class="subtitle" id="page-topics" data-i18n="interview_loading">Ë™≠„ÅøËæº„Åø‰∏≠...</div>
    <div id="status" class="status-box status-idle" data-i18n="status_idle">ÂæÖÊ©ü‰∏≠</div>
    
    <div id="visualizer-container" class="inactive-visualizer">
        <canvas id="visualizer" width="600" height="100"></canvas>
    </div>

    <div class="content-wrapper">
        <div class="chat-section"><div id="chat-log"></div></div>
        <div class="summary-section" id="summary-section">
            <div class="summary-title" data-i18n="summary_title">üìù „Ç§„É≥„Çø„Éì„É•„ÉºÁµêÊûú„Çµ„Éû„É™„Éº</div>
            <div id="summary-box" data-i18n="summary_placeholder">„Åì„Åì„Å´ÁµêÊûú„ÅåË°®Á§∫„Åï„Çå„Åæ„Åô...</div>
            <button id="copy-btn" class="copy-btn" onclick="copySummary()" disabled data-i18n="btn_copy_summary">üìã „Çµ„Éû„É™„Éº„Çí„Ç≥„Éî„Éº</button>
        </div>
    </div>

    <div class="controls">
        <div id="ctrl-idle">
            <button class="btn btn-start" onclick="startInterview()" data-i18n="btn_start_interview">„Ç§„É≥„Çø„Éì„É•„ÉºÈñãÂßã</button>
        </div>

        <div id="interview-actions-wrapper" class="interview-actions" style="display:none;">
            <div id="skip-btn-container">
                <button id="skip-btn" onclick="skipSpeech()" data-i18n="btn_skip">‚è© Ë™≠„Åø‰∏ä„ÅíSkip</button>
            </div>

            <div id="text-input-container" style="display:none;">
                <div class="text-input-row">
                    <input type="text" id="text-input" placeholder="„ÉÜ„Ç≠„Çπ„Éà„ÅßÂÖ•Âäõ..." data-i18n-ph="ph_text_input" onkeydown="if(event.key==='Enter')sendTextInput()">
                    <button onclick="sendTextInput()" data-i18n="btn_send">ÈÄÅ‰ø°</button>
                </div>
            </div>

            <div id="ctrl-actions" style="display:none; text-align:center;">
                <button id="reply-btn" onclick="forceReply()" data-i18n="btn_reply">üí¨ Ëøî‰ø°„Åó„Å¶</button>
                <button id="next-topic-btn" onclick="requestNextTopic()" data-i18n="btn_next_topic">‚è≠ Ê¨°„ÅÆË©±È°å„Å∏</button>
            </div>
        </div>

        <div id="ctrl-running" class="running-controls" style="display:none;">
            <button class="btn btn-abort" onclick="abortInterview()" data-i18n="btn_abort">‰∏≠Ê≠¢„Åô„Çã</button>
            <button class="btn btn-finish" onclick="forceFinish()" data-i18n="btn_finish">ÁµÇ‰∫Ü„Åô„Çã</button>
        </div>

        <div id="ctrl-finished" style="display:none;">
            <button id="back-btn" class="btn btn-back" onclick="window.location.href='index.html'" disabled data-i18n="btn_back">Ë®≠ÂÆöÁîªÈù¢„Å´Êàª„Çã</button>
        </div>
    </div>

    <!-- „Éá„Éê„ÉÉ„Ç∞„É¢„Éº„Éâ -->
    <div class="debug-toggle-container">
        <label class="debug-toggle">
            <input type="checkbox" id="debug-mode-toggle" onchange="toggleDebugMode()">
            <span data-i18n="debug_label">üêõ Debug Mode</span>
        </label>
    </div>
    <div id="debug-box" class="debug-box">
        <div style="color: #888; margin-bottom: 10px;" data-i18n="debug_placeholder">API„Ç≥„Éº„É´„ÅÆ„Éó„É≠„É≥„Éó„ÉàÊÉÖÂ†±„Åå„Åì„Åì„Å´Ë°®Á§∫„Åï„Çå„Åæ„Åô</div>
    </div>
    <div class="build-version">Build: 2026-02-09 22:00</div>
</div>

<script src="i18n.js"></script>
<script src="lang/ja.js"></script>
<script src="lang/en.js"></script>
<script src="lang/de.js"></script>
<script>
    const DB_NAME = "InterviewDB";
    const DB_VERSION = 1;
    const STORE_NAME = "archives";

    let CONFIG = {};
    let isInterviewerSpeaking = false;
    let isThinking = false;
    let conversationHistory = [];
    let synth = window.speechSynthesis;
    let audioContext, analyser, dataArray, canvasCtx, visualizerFrame;
    let availableVoices = [];

    let timerInterval;
    let startTime;

    let currentTopicIndex = 0;

    // „Éá„Éê„ÉÉ„Ç∞„É¢„Éº„ÉâÈñ¢ÈÄ£
    let debugMode = false;
    let promptLog = [];  // ÂêÑAPI„Ç≥„Éº„É´„ÅÆ„Éó„É≠„É≥„Éó„ÉàÊÉÖÂ†±„ÇíË®òÈå≤ 

    window.speechSynthesis.onvoiceschanged = () => { availableVoices = window.speechSynthesis.getVoices(); };

    window.onload = () => {
        const storedConfig = localStorage.getItem('interviewConfig');
        if (storedConfig) {
            CONFIG = JSON.parse(storedConfig);
        } else {
            alert(I18N.t('alert_no_config'));
            window.location.href = 'index.html';
            return;
        }

        // Initialize I18N with saved language
        if (CONFIG.language && I18N.langs[CONFIG.language]) {
            I18N.currentLang = CONFIG.language;
            document.documentElement.lang = CONFIG.language;
        }
        I18N.init();
        I18N.applyToDOM();

        document.getElementById('page-title').innerText = CONFIG.title;
        const sttLabel = (CONFIG.sttMode === 'webspeech') ? 'Web Speech API' : 'Groq Whisper';
        document.getElementById('page-topics').innerText = I18N.t('topics_info').replace('{count}', CONFIG.topics.length).replace('{stt}', sttLabel);

        setupVisualizerCanvas();
        setButtonState("IDLE");
    };

    function setButtonState(state) {
        document.getElementById('ctrl-idle').style.display = 'none';
        document.getElementById('ctrl-running').style.display = 'none';
        document.getElementById('ctrl-finished').style.display = 'none';
        document.getElementById('interview-actions-wrapper').style.display = 'none';
        document.getElementById('ctrl-actions').style.display = 'none';
        document.getElementById('text-input-container').style.display = 'none';
        document.getElementById('skip-btn').style.display = 'none';

        if (state === "IDLE") {
            document.getElementById('ctrl-idle').style.display = 'block';
        } else if (state === "RUNNING") {
            document.getElementById('interview-actions-wrapper').style.display = 'block';
            document.getElementById('ctrl-running').style.display = 'flex';
            document.getElementById('ctrl-actions').style.display = 'block';
            document.getElementById('text-input-container').style.display = 'block';
        } else if (state === "FINISHED") {
            document.getElementById('ctrl-finished').style.display = 'block';
        }
    }

    function abortInterview() {
        if (confirm(I18N.t('confirm_abort'))) {
            interviewRunning = false;
            stopRecognition();
            clearInterval(timerInterval);
            window.location.href = 'index.html';
        }
    }

    function forceFinish() {
        if (confirm(I18N.t('confirm_finish'))) {
            interviewRunning = false;
            stopTimer();
            stopRecognition();
            updateStatus('finishing', I18N.t('status_finishing'));
            document.getElementById('ctrl-running').style.display = 'none';
            document.getElementById('interview-actions-wrapper').style.display = 'none';
            generateSummary();
        }
    }

    function startTimer() {
        startTime = Date.now();
        clearInterval(timerInterval);
        timerInterval = setInterval(() => {
            const diff = Date.now() - startTime;
            const mins = Math.floor(diff / 60000);
            const secs = Math.floor((diff % 60000) / 1000);
            document.getElementById('timer').innerText = 
                (mins < 10 ? "0" : "") + mins + ":" + (secs < 10 ? "0" : "") + secs;
        }, 1000);
    }

    function stopTimer() {
        clearInterval(timerInterval);
    }

    function skipSpeech() {
        if (synth.speaking || synth.pending) {
            synth.cancel();
            isInterviewerSpeaking = false;
            isThinking = false;
            stopSpeechInterruptionDetection();
            document.getElementById('skip-btn').style.display = 'none';

            if (!document.querySelector('.status-finishing')) {
                startListening();
            }
        }
    }

    async function startInterview() {
        if (!CONFIG.apiKey) return alert(I18N.t('alert_no_api_key'));

        conversationHistory = [];
        currentTopicIndex = 0;
        promptLog = [];
        consecutiveSilenceCount = 0;
        sttMode = CONFIG.sttMode || 'groq';

        document.getElementById('chat-log').innerHTML = '';
        document.getElementById('summary-section').style.display = 'none';
        document.getElementById('summary-box').innerText = '...';
        document.getElementById('debug-box').innerHTML = `<div style="color: #888; margin-bottom: 10px;">${I18N.t('debug_placeholder')}</div>`;

        await initAudioContext();
        setButtonState("RUNNING");
        interviewRunning = true;
        startTimer();

        const intro = I18N.t('interview_intro');
        addMessage('ai', intro);
        conversationHistory.push({ role: "assistant", content: intro });
        speak(intro);
    }

    function stopRecognition() {
        isInterviewerSpeaking = false;
        isThinking = false;
        stopSpeechInterruptionDetection();
        stopListening();
        synth.cancel();
        toggleVisualizer(false);
    }

    async function processUserResponse(userText) {
        console.log('[DEBUG] processUserResponse called with:', userText.substring(0, 50));
        isThinking = true;
        updateStatus('thinking', I18N.t('status_thinking'));

        conversationHistory.push({ role: "user", content: userText });

        // ÁµÇ‰∫ÜÂ∏åÊúõ„ÉÅ„Çß„ÉÉ„ÇØ
        let forceEnd = false;
        const endKeywords = I18N.t('end_keywords');
        if (Array.isArray(endKeywords)) {
            forceEnd = endKeywords.some(kw => userText.includes(kw));
        }

        try {
            const systemPrompt = buildDynamicPrompt(forceEnd);
            const rawAiText = await callGroqAPI(conversationHistory, systemPrompt);

            // [[NEXT]]„Éû„Éº„Ç´„Éº„ÇíÊ§úÂá∫„Åó„Å¶„Éà„Éî„ÉÉ„ÇØÁßªË°å
            let aiText = rawAiText;
            if (rawAiText.includes("[[NEXT]]")) {
                aiText = rawAiText.replace("[[NEXT]]", "").trim();
                currentTopicIndex++;
                console.log(`Topic advanced to: ${currentTopicIndex}`);
            }

            addMessage('ai', aiText);
            conversationHistory.push({ role: "assistant", content: aiText });

            if (aiText.includes(I18N.t('end_detected_speak')) || aiText.includes(I18N.t('end_detected_end'))) {
                interviewRunning = false;
                stopTimer();
                updateStatus('finishing', I18N.t('status_farewell'));

                speak(aiText, () => {
                    updateStatus('finishing', I18N.t('status_summary_creating'));
                    stopRecognition();
                    generateSummary();
                });
            } else {
                speak(aiText);
            }

        } catch (error) {
            console.error(error);
            addMessage('ai', `<span class="error-msg">${error.message}</span>`);
            speak(I18N.t('error_occurred'));
            updateStatus('error', I18N.t('status_error_short'));
            isThinking = false;
        }
    }

    function buildDynamicPrompt(forceEnd = false) {
        const contextText = CONFIG.context ? `\n# Pre-knowledge / Background Context\n${CONFIG.context}\n` : "";

        // „Éà„Éî„ÉÉ„ÇØ‰∏ÄË¶ß„Å®ÁèæÂú®‰ΩçÁΩÆ
        const topicsList = CONFIG.topics.map((t, i) => {
            if (i < currentTopicIndex) return `  ‚úì ${t} (${I18N.t('prompt_topic_done')})`;
            if (i === currentTopicIndex) return `  ‚ñ∂ ${t} (${I18N.t('prompt_topic_current')})`;
            return `  ‚óã ${t}`;
        }).join('\n');

        const currentTopic = CONFIG.topics[currentTopicIndex] || null;
        const remainingCount = CONFIG.topics.length - currentTopicIndex;
        const isLastTopic = currentTopicIndex >= CONFIG.topics.length - 1;
        const allDone = currentTopicIndex >= CONFIG.topics.length;

        // Áä∂Ê≥Å„Å´Âøú„Åò„ÅüÊåáÁ§∫
        let situationInstruction = "";
        if (forceEnd) {
            situationInstruction = '\n' + I18N.t('prompt_situation_force_end');
        } else if (allDone) {
            situationInstruction = '\n' + I18N.t('prompt_situation_all_done');
        } else {
            const depthHint = CONFIG.depth === "deep"
                ? I18N.t('prompt_depth_deep')
                : I18N.t('prompt_depth_standard');
            situationInstruction = `
## ${I18N.t('prompt_current_topic')}: „Äå${currentTopic}„Äç
- ${I18N.t('prompt_remaining')}: ${remainingCount}${isLastTopic ? ' ' + I18N.t('prompt_last_topic_note') : ''}
- Style: ${depthHint}

${topicsList}`;
        }

        return `
# Persona
${CONFIG.persona}
${contextText}
${situationInstruction}

${I18N.t('prompt_rules')}
`;
    }

    // --- API Call (Token optimization) ---
    async function callGroqAPI(history, systemPrompt, customTemp = 0.7, customMaxTokens = 1024, callType = 'interview') {
        const url = "https://api.groq.com/openai/v1/chat/completions";

        // ‚òÖ„Éà„Éº„ÇØ„É≥ÁØÄÁ¥Ñ„É≠„Ç∏„ÉÉ„ÇØ: Â±•Ê≠¥„ÅØÁõ¥Ëøë„ÅÆ10‰ª∂Ôºà5ÂæÄÂæ©Ôºâ„ÅÆ„ÅøÈÄÅ‰ø°„Åô„Çã
        const MAX_HISTORY = 10;
        const recentHistory = history.length > MAX_HISTORY ? history.slice(-MAX_HISTORY) : history;

        const messages = [{ role: "system", content: systemPrompt }, ...recentHistory];

        const payload = {
            model: CONFIG.modelName || "llama-3.1-8b-instant",
            messages: messages,
            temperature: customTemp,
            max_tokens: customMaxTokens
        };

        // „Éá„Éê„ÉÉ„Ç∞: „É™„ÇØ„Ç®„Çπ„ÉàÈÄÅ‰ø°Ââç„Å´Ë®òÈå≤
        addDebugEntry(`${callType} - Sending Request`, systemPrompt, messages);
        console.log('[DEBUG] API Request starting...', { model: payload.model, messageCount: messages.length });

        // „Çø„Ç§„É†„Ç¢„Ç¶„Éà‰ªò„ÅçfetchÔºà30ÁßíÔºâ
        const controller = new AbortController();
        const timeoutId = setTimeout(() => {
            controller.abort();
            console.log('[DEBUG] API Request timeout after 30s');
        }, 30000);

        try {
            const response = await fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${CONFIG.apiKey}`
                },
                body: JSON.stringify(payload),
                signal: controller.signal
            });

            clearTimeout(timeoutId);
            console.log('[DEBUG] API Response received, status:', response.status);

            if (!response.ok) {
                const err = await response.json().catch(() => ({}));
                // Rate Limit„Ç®„É©„Éº„ÅÆÂ†¥Âêà„ÅØ„ÄÅ„É¶„Éº„Ç∂„Éº„Å´ÂàÜ„Åã„Çä„ÇÑ„Åô„ÅèË°®Á§∫
                if (response.status === 429) {
                    throw new Error(I18N.t('error_rate_limit'));
                }
                throw new Error(`Groq API Error: ${err.error?.message || response.statusText}`);
            }

            const data = await response.json();
            console.log('[DEBUG] API Response parsed successfully');
            const responseText = data.choices[0].message.content;

            // „Éá„Éê„ÉÉ„Ç∞: „É¨„Çπ„Éù„É≥„ÇπÂèó‰ø°Âæå„Å´Ë®òÈå≤„ÇíÊõ¥Êñ∞
            if (promptLog.length > 0) {
                promptLog[promptLog.length - 1].response = responseText;
                promptLog[promptLog.length - 1].status = `${callType} - Response Received`;
            }

            // „Éá„Éê„ÉÉ„Ç∞ÁîªÈù¢„ÇÇÊõ¥Êñ∞
            updateDebugEntryResponse(responseText);

            return responseText;
        } catch (err) {
            clearTimeout(timeoutId);
            if (err.name === 'AbortError') {
                throw new Error(I18N.t('error_timeout'));
            }
            throw err;
        }
    }

    async function generateSummary() {
        const summarySection = document.getElementById('summary-section');
        summarySection.style.display = 'block';
        const summaryBox = document.getElementById('summary-box');
        summaryBox.innerText = I18N.t('status_summary_generating');

        const historyText = conversationHistory.map(item => `${item.role}: ${item.content}`).join("\n");
        const prompt = I18N.t('prompt_summary_instruction').replace('{history}', historyText);

        try {
            const summaryText = await callGroqAPI([{ role: "user", content: prompt }], I18N.t('prompt_summary_system'), 0.7, 4096, 'summary');
            summaryBox.innerText = summaryText;
            updateStatus('idle', I18N.t('status_complete'));
            setButtonState("FINISHED");
            // „Çµ„Éû„É™„ÉºÂÆå‰∫ÜÂæå„Å´„Éú„Çø„É≥„ÇíÊúâÂäπÂåñ
            document.getElementById('copy-btn').disabled = false;
            document.getElementById('back-btn').disabled = false;
            await saveToDB(summaryText);
        } catch (error) {
            summaryBox.innerHTML = `<span style="color:red;">${error.message}</span>`;
            updateStatus('error', '„Ç®„É©„Éº');
            // „Ç®„É©„ÉºÊôÇ„ÇÇÊàª„Çã„Éú„Çø„É≥„ÅØÊúâÂäπÂåñ
            document.getElementById('back-btn').disabled = false;
            setButtonState("FINISHED");
        }
    }

    function openDB() {
        return new Promise((r, j) => {
            const req = indexedDB.open(DB_NAME, DB_VERSION);
            req.onupgradeneeded = (e) => { 
                const db = e.target.result; 
                if (!db.objectStoreNames.contains(STORE_NAME)) db.createObjectStore(STORE_NAME, { keyPath: "id" });
            };
            req.onsuccess = (e) => r(e.target.result);
            req.onerror = (e) => j(e.target.error);
        });
    }

    async function saveToDB(summaryText) {
        try {
            const db = await openDB();
            const tx = db.transaction(STORE_NAME, "readwrite");
            const store = tx.objectStore(STORE_NAME);
            const record = {
                id: Date.now(),
                title: CONFIG.title,
                date: new Date().toLocaleString(),
                topics: CONFIG.topics,
                history: conversationHistory,
                summary: summaryText,
                // „Éó„É≠„É≥„Éó„ÉàÂ±•Ê≠¥„Çí‰øùÂ≠òÔºà„Éá„Éê„ÉÉ„Ç∞Áî®Ôºâ
                promptLog: promptLog,
                // Ë®≠ÂÆöÊÉÖÂ†±„ÇÇ‰øùÂ≠ò
                settings: {
                    modelName: CONFIG.modelName || "llama-3.1-8b-instant",
                    context: CONFIG.context || "",
                    personaType: CONFIG.personaType || "listener",
                    persona: CONFIG.persona || "",
                    voiceName: CONFIG.voiceName || "",
                    rate: CONFIG.rate || 1.3,
                    depth: CONFIG.depth || "standard",
                    sttMode: CONFIG.sttMode || "groq"
                }
            };
            store.add(record);
        } catch (e) { console.error("DB Error:", e); }
    }

    function copySummary() {
        const text = document.getElementById('summary-box').innerText;
        navigator.clipboard.writeText(text).then(() => alert(I18N.t('alert_copied')));
    }

    function cleanTextForSpeech(text) { return text.replace(/[\*#_`~]/g, ''); }

    function configureUtterance(utterance) {
        utterance.rate = CONFIG.rate; utterance.volume = 1.0; utterance.pitch = 1.0;
        utterance.lang = I18N.speechLang;
        if (availableVoices.length === 0) availableVoices = window.speechSynthesis.getVoices();
        const selectedVoice = availableVoices.find(v => v.name === CONFIG.voiceName);
        if (selectedVoice) {
            utterance.voice = selectedVoice;
        } else {
            // Fallback: find any voice matching current language
            const langCode = I18N.speechLang.split('-')[0];
            const fallbackVoice = availableVoices.find(v => v.lang.includes(langCode));
            if (fallbackVoice) utterance.voice = fallbackVoice;
        }
    }
    
    // --- STT Engine (Groq Whisper / Web Speech API) ---

    let sttMode = 'groq'; // 'groq' or 'webspeech' ‚Äî set from CONFIG
    let recognition = null; // Web Speech API instance
    let mediaRecorder = null;
    let audioChunks = [];
    let audioStream = null;
    let silenceCheckInterval = null;
    let speechDetected = false;
    let silenceStartTime = 0;
    let recordingStartTime = 0;
    let isListening = false;
    let interviewRunning = false;
    let consecutiveSilenceCount = 0;
    const SILENCE_THRESHOLD = 5;
    const SILENCE_DURATION = 2000;
    const MAX_RECORD_DURATION = 30000;
    const MAX_SILENCE_ROUNDS = 3;

    // --- Ë™≠„Åø‰∏ä„Åí‰∏≠„ÅÆ„É¶„Éº„Ç∂„ÉºÈü≥Â£∞Ââ≤„ÇäËæº„ÅøÊ§úÂá∫ ---
    let speechInterruptionInterval = null;
    let userSpeechStartTime = 0;
    const INTERRUPT_RMS_THRESHOLD = 10;  // AIË™≠„Åø‰∏ä„Åí‰∏≠„ÅÆÊ§úÂá∫ÈñæÂÄ§ÔºàÈÄöÂ∏∏„Çà„ÇäÈ´ò„ÇÅÔºâ
    const INTERRUPT_DURATION = 1000;     // 1ÁßíÈñì„ÅÆÁ∂ôÁ∂öÈü≥Â£∞„ÅßÂâ≤„ÇäËæº„Åø

    function startSpeechInterruptionDetection() {
        stopSpeechInterruptionDetection();
        userSpeechStartTime = 0;

        speechInterruptionInterval = setInterval(() => {
            if (!analyser || !isInterviewerSpeaking) {
                stopSpeechInterruptionDetection();
                return;
            }

            analyser.getByteTimeDomainData(dataArray);
            let sum = 0;
            for (let i = 0; i < dataArray.length; i++) {
                const v = (dataArray[i] - 128) / 128;
                sum += v * v;
            }
            const rms = Math.sqrt(sum / dataArray.length) * 100;

            if (rms > INTERRUPT_RMS_THRESHOLD) {
                if (userSpeechStartTime === 0) {
                    userSpeechStartTime = Date.now();
                } else if (Date.now() - userSpeechStartTime > INTERRUPT_DURATION) {
                    console.log('[STT] User voice detected during AI speech, interrupting (RMS:', rms.toFixed(1), ')');
                    stopSpeechInterruptionDetection();
                    synth.cancel();
                    isInterviewerSpeaking = false;
                    isThinking = false;
                    document.getElementById('skip-btn').style.display = 'none';
                    startListening();
                }
            } else {
                userSpeechStartTime = 0;
            }
        }, 100);
    }

    function stopSpeechInterruptionDetection() {
        if (speechInterruptionInterval) {
            clearInterval(speechInterruptionInterval);
            speechInterruptionInterval = null;
        }
        userSpeechStartTime = 0;
    }

    function isHallucination(text) {
        if (!text || !text.trim()) return true;
        const t = text.trim();
        // 3ÊñáÂ≠ó‰ª•‰∏ã„ÅØÁÑ°Ë¶ñ
        if (t.length <= 3) return true;
        // Âêå„ÅòÊñáÂ≠ó„ÅÆÁπ∞„ÇäËøî„ÅóÔºà„Å≠„Åá„Å≠„Åá„Å≠„Åá...„ÄÅ„ÅÇ„ÅÇ„ÅÇ„ÅÇ...Á≠âÔºâ
        // 2-4ÊñáÂ≠ó„ÅÆ„Éë„Çø„Éº„É≥„ÅåÂÖ®‰Ωì„ÅÆ60%‰ª•‰∏ä„ÇíÂç†„ÇÅ„Åü„Çâ„Éè„É´„Ç∑„Éç„Éº„Ç∑„Éß„É≥
        for (let len = 1; len <= 4; len++) {
            const pat = t.substring(0, len);
            const repeated = pat.repeat(Math.ceil(t.length / len)).substring(0, t.length);
            const matchCount = [...t].filter((c, i) => c === repeated[i]).length;
            if (matchCount / t.length > 0.6) {
                console.log('[STT] Hallucination detected (repeat):', t.substring(0, 30));
                return true;
            }
        }
        // „É¶„Éã„Éº„ÇØÊñáÂ≠ó„ÅåÊ•µÁ´Ø„Å´Â∞ë„Å™„ÅÑÔºàÂÖ®‰Ωì„ÅÆ10%‰ª•‰∏ãÔºâ
        const unique = new Set(t.replace(/\s/g, '')).size;
        if (unique <= 2 && t.length > 5) {
            console.log('[STT] Hallucination detected (low unique):', t.substring(0, 30));
            return true;
        }
        return false;
    }

    function getRecorderMimeType() {
        const types = ['audio/webm;codecs=opus', 'audio/webm', 'audio/mp4', 'audio/ogg;codecs=opus'];
        for (const type of types) {
            if (MediaRecorder.isTypeSupported(type)) return type;
        }
        return '';
    }

    function startListening() {
        if (isListening || !interviewRunning) return;
        if (sttMode === 'webspeech') {
            startListeningWebSpeech();
        } else {
            startListeningGroq();
        }
    }

    function startListeningGroq() {
        if (isListening || !audioStream) return;
        isListening = true;
        audioChunks = [];
        speechDetected = false;
        silenceStartTime = 0;
        recordingStartTime = Date.now();

        updateStatus('listening', I18N.t('status_listening'));
        toggleVisualizer(true);
        console.log('[STT] startListeningGroq');

        const mimeType = getRecorderMimeType();
        const options = mimeType ? { mimeType } : {};
        mediaRecorder = new MediaRecorder(audioStream, options);

        mediaRecorder.ondataavailable = (e) => {
            if (e.data.size > 0) audioChunks.push(e.data);
        };

        mediaRecorder.onstop = async () => {
            console.log('[STT] MediaRecorder stopped, chunks:', audioChunks.length, 'forceReply:', forceReplyMode);
            const wasForceReply = forceReplyMode;
            forceReplyMode = false;

            if (audioChunks.length === 0 || !speechDetected) {
                if (wasForceReply) {
                    consecutiveSilenceCount = 0;
                    addMessage('user', I18N.t('text_continue'));
                    processUserResponse(I18N.t('text_continue_request'));
                    return;
                }
                consecutiveSilenceCount++;
                if (consecutiveSilenceCount >= MAX_SILENCE_ROUNDS) {
                    handleSilenceTimeout();
                    return;
                }
                if (!isInterviewerSpeaking && !isThinking) {
                    startListening();
                }
                return;
            }
            const blob = new Blob(audioChunks, { type: mimeType || 'audio/webm' });
            updateStatus('thinking', I18N.t('status_recognizing'));
            toggleVisualizer(false);
            try {
                const text = await transcribeGroq(blob);
                console.log('[STT] Transcribed:', text);
                if (isHallucination(text)) {
                    consecutiveSilenceCount++;
                    console.log('[STT] Hallucination filtered, silence count:', consecutiveSilenceCount);
                    if (consecutiveSilenceCount >= MAX_SILENCE_ROUNDS) {
                        handleSilenceTimeout();
                        return;
                    }
                    if (!isInterviewerSpeaking && !isThinking) {
                        startListening();
                    }
                    return;
                }
                consecutiveSilenceCount = 0;
                if (text && text.trim() && !isInterviewerSpeaking && !isThinking) {
                    addMessage('user', text.trim());
                    processUserResponse(text.trim());
                } else if (wasForceReply) {
                    addMessage('user', I18N.t('text_continue'));
                    processUserResponse(I18N.t('text_continue_request'));
                } else {
                    startListening();
                }
            } catch (e) {
                console.error('[STT] Transcription error:', e);
                updateStatus('error', I18N.t('error_stt') + e.message);
                setTimeout(() => startListening(), 1000);
            }
        };

        mediaRecorder.start(250);
        startSilenceDetection();
    }

    function stopListening() {
        if (sttMode === 'webspeech') {
            stopListeningWebSpeech();
        } else {
            stopListeningGroq();
        }
    }

    function stopListeningGroq() {
        isListening = false;
        if (silenceCheckInterval) {
            clearInterval(silenceCheckInterval);
            silenceCheckInterval = null;
        }
        if (mediaRecorder && mediaRecorder.state !== 'inactive') {
            try { mediaRecorder.stop(); } catch(e) {}
        }
        toggleVisualizer(false);
        console.log('[STT] stopListeningGroq');
    }

    // --- Web Speech API ---

    function startListeningWebSpeech() {
        if (isListening) return;
        isListening = true;

        updateStatus('listening', I18N.t('status_listening'));
        toggleVisualizer(true);
        console.log('[STT] startListeningWebSpeech');

        if (!recognition) {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (!SpeechRecognition) {
                updateStatus('error', I18N.t('error_stt_unsupported'));
                isListening = false;
                return;
            }
            recognition = new SpeechRecognition();
            recognition.lang = I18N.speechLang;
            recognition.continuous = false;
            recognition.interimResults = false;
        }

        recognition.onresult = (event) => {
            const text = event.results[event.results.length - 1][0].transcript;
            console.log('[STT] Web Speech result:', text);
            isListening = false;
            toggleVisualizer(false);

            if (isHallucination(text)) {
                consecutiveSilenceCount++;
                if (consecutiveSilenceCount >= MAX_SILENCE_ROUNDS) {
                    handleSilenceTimeout();
                    return;
                }
                if (!isInterviewerSpeaking && !isThinking) startListening();
                return;
            }

            consecutiveSilenceCount = 0;
            if (text && text.trim() && !isInterviewerSpeaking && !isThinking) {
                addMessage('user', text.trim());
                processUserResponse(text.trim());
            } else {
                startListening();
            }
        };

        recognition.onerror = (event) => {
            console.error('[STT] Web Speech error:', event.error);
            isListening = false;

            if (event.error === 'no-speech') {
                consecutiveSilenceCount++;
                if (consecutiveSilenceCount >= MAX_SILENCE_ROUNDS) {
                    handleSilenceTimeout();
                    return;
                }
                if (interviewRunning && !isInterviewerSpeaking && !isThinking) {
                    setTimeout(() => startListening(), 300);
                }
                return;
            }

            if (event.error === 'network') {
                updateStatus('error', I18N.t('error_stt_network'));
                return;
            }

            if (event.error === 'aborted' || event.error === 'not-allowed') return;

            updateStatus('error', I18N.t('error_stt') + event.error);
            if (interviewRunning) setTimeout(() => startListening(), 1000);
        };

        recognition.onend = () => {
            console.log('[STT] Web Speech onend, isListening:', isListening);
            if (isListening && interviewRunning && !isInterviewerSpeaking && !isThinking) {
                // Â∞ë„ÅóÂæÖ„Å£„Å¶„Åã„Çâ„É™„Çπ„Çø„Éº„ÉàÔºàÂâç„ÅÆ„Çª„ÉÉ„Ç∑„Éß„É≥ÂÆå‰∫Ü„ÇíÁ¢∫ÂÆü„Å´„Åô„ÇãÔºâ
                setTimeout(() => {
                    if (isListening && interviewRunning && !isInterviewerSpeaking && !isThinking) {
                        try { recognition.start(); } catch(e) {
                            console.warn('[STT] Web Speech restart failed:', e.message);
                            isListening = false;
                            setTimeout(() => startListening(), 300);
                        }
                    }
                }, 100);
            }
        };

        try {
            // Êó¢Â≠ò„Çª„ÉÉ„Ç∑„Éß„É≥„ÅåÊÆã„Å£„Å¶„ÅÑ„ÇãÂèØËÉΩÊÄß„Åå„ÅÇ„Çã„ÅÆ„Åßabort„Åó„Å¶„Åã„ÇâÈñãÂßã
            try { recognition.abort(); } catch(e2) {}
            setTimeout(() => {
                try {
                    recognition.start();
                } catch (e) {
                    console.error('[STT] Web Speech start error:', e);
                    isListening = false;
                    // „É™„Éà„É©„Ç§
                    if (interviewRunning && !isInterviewerSpeaking && !isThinking) {
                        setTimeout(() => startListening(), 500);
                    }
                }
            }, 100);
        } catch (e) {
            console.error('[STT] Web Speech abort error:', e);
            isListening = false;
        }
    }

    function stopListeningWebSpeech() {
        isListening = false;
        if (recognition) {
            try { recognition.stop(); } catch(e) {}
        }
        toggleVisualizer(false);
        console.log('[STT] stopListeningWebSpeech');
    }

    function startSilenceDetection() {
        if (silenceCheckInterval) clearInterval(silenceCheckInterval);
        silenceCheckInterval = setInterval(() => {
            if (!analyser || !isListening) return;

            analyser.getByteTimeDomainData(dataArray);
            let sum = 0;
            for (let i = 0; i < dataArray.length; i++) {
                const v = (dataArray[i] - 128) / 128;
                sum += v * v;
            }
            const rms = Math.sqrt(sum / dataArray.length) * 100;

            if (rms > SILENCE_THRESHOLD) {
                speechDetected = true;
                silenceStartTime = 0;
            } else if (speechDetected) {
                if (silenceStartTime === 0) {
                    silenceStartTime = Date.now();
                } else if (Date.now() - silenceStartTime > SILENCE_DURATION) {
                    console.log('[STT] Silence detected, stopping recording');
                    stopListening();
                    return;
                }
            }

            if (Date.now() - recordingStartTime > MAX_RECORD_DURATION) {
                console.log('[STT] Max duration reached, stopping recording');
                stopListening();
            }
        }, 100);
    }

    async function transcribeGroq(audioBlob) {
        const mimeType = audioBlob.type || 'audio/webm';
        const ext = mimeType.includes('mp4') ? 'mp4' : mimeType.includes('ogg') ? 'ogg' : 'webm';

        const formData = new FormData();
        formData.append('file', audioBlob, `audio.${ext}`);
        formData.append('model', 'whisper-large-v3-turbo');
        formData.append('language', I18N.whisperLang);
        formData.append('response_format', 'json');

        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 15000);

        try {
            const response = await fetch('https://api.groq.com/openai/v1/audio/transcriptions', {
                method: 'POST',
                headers: { 'Authorization': `Bearer ${CONFIG.apiKey}` },
                body: formData,
                signal: controller.signal
            });
            clearTimeout(timeoutId);

            if (!response.ok) {
                const err = await response.json().catch(() => ({}));
                throw new Error(`Whisper API Error: ${err.error?.message || response.statusText}`);
            }

            const data = await response.json();
            console.log('[STT] Groq Whisper result:', data.text);
            return data.text;
        } catch (err) {
            clearTimeout(timeoutId);
            if (err.name === 'AbortError') throw new Error(I18N.t('error_stt_timeout'));
            throw err;
        }
    }

    function handleSilenceTimeout() {
        if (!interviewRunning) return;
        console.log('[STT] Silence timeout - asking user');
        consecutiveSilenceCount = 0;
        updateStatus('idle', I18N.t('status_silence'));
        toggleVisualizer(false);
        const msg = I18N.t('silence_message');
        addMessage('ai', msg);
        speak(msg, () => {
            // Áô∫Ë©±Âæå„ÄÅ„É¶„Éº„Ç∂„Éº„ÅÆÂøúÁ≠î„ÇíÂæÖ„Å§ÔºàstartListening„ÅØ speak() „ÅÆ onend „ÅßÂëº„Å∞„Çå„ÇãÔºâ
            // ‚Üí speak „ÅÆ onComplete „ÇíÊåáÂÆö„Åó„Å¶„ÅÑ„Çã„ÅÆ„Åß„ÄÅËá™ÂãïÁöÑ„Å´„ÅØ startListening „Åó„Å™„ÅÑ
            // „É¶„Éº„Ç∂„Éº„Åå„ÄåËøî‰ø°„Åó„Å¶„Äç„ÇÑ„ÉÜ„Ç≠„Çπ„ÉàÂÖ•Âäõ„ÅßÂøúÁ≠î„Åô„Çã„ÅÆ„ÇíÂæÖ„Å§
            updateStatus('listening', I18N.t('status_listening'));
            toggleVisualizer(true);
            // Áü≠„ÅÑÂæÖÊ©üÂæå„Å´„É™„Çπ„Éã„É≥„Ç∞ÈñãÂßã
            setTimeout(() => startListening(), 500);
        });
    }

    // --- „É¶„Éº„Ç∂„ÉºÊìç‰Ωú„Éú„Çø„É≥ ---

    let forceReplyMode = false;

    async function forceReply() {
        if (!isListening && !isInterviewerSpeaking && !isThinking) return;
        console.log('[UI] forceReply called');

        // Ë™≠„Åø‰∏ä„Åí‰∏≠„Å™„Çâ‰∏≠Ê≠¢
        if (synth.speaking || synth.pending) {
            synth.cancel();
            isInterviewerSpeaking = false;
            document.getElementById('skip-btn').style.display = 'none';
        }
        stopSpeechInterruptionDetection();

        if (isListening) {
            if (sttMode === 'webspeech') {
                // Web Speech API: ÂÅúÊ≠¢„Åó„Å¶Áõ¥Êé•AI„Å´‰æùÈ†º
                stopListening();
                addMessage('user', I18N.t('text_continue'));
                processUserResponse(I18N.t('text_continue_request'));
                return;
            }
            // Groq mode: forceReplyMode„Éï„É©„Ç∞„Åßonstop„Éè„É≥„Éâ„É©„Å´Âà∂Âæ°„ÇíÂßîË≠≤
            forceReplyMode = true;
            stopListening();
            return;
        }

        // ËÅ¥Ë¨õ‰∏≠„Åß„Å™„Åë„Çå„Å∞Áõ¥Êé•AI„Å´Á∂öË°å„Çí‰æùÈ†º
        addMessage('user', I18N.t('text_continue'));
        processUserResponse(I18N.t('text_continue_request'));
    }

    function sendTextInput() {
        const input = document.getElementById('text-input');
        const text = input.value.trim();
        if (!text) return;
        input.value = '';

        console.log('[UI] sendTextInput:', text);
        // Ë™≠„Åø‰∏ä„Åí‰∏≠„Å™„Çâ‰∏≠Ê≠¢
        if (synth.speaking || synth.pending) {
            synth.cancel();
            isInterviewerSpeaking = false;
            isThinking = false;
            document.getElementById('skip-btn').style.display = 'none';
        }
        stopSpeechInterruptionDetection();
        stopListening();
        addMessage('user', text);
        processUserResponse(text);
    }

    function requestNextTopic() {
        console.log('[UI] requestNextTopic');
        // Ë™≠„Åø‰∏ä„Åí‰∏≠„Å™„Çâ‰∏≠Ê≠¢
        if (synth.speaking || synth.pending) {
            synth.cancel();
            isInterviewerSpeaking = false;
            isThinking = false;
            document.getElementById('skip-btn').style.display = 'none';
        }
        stopSpeechInterruptionDetection();
        stopListening();
        addMessage('user', I18N.t('text_next_topic'));
        processUserResponse(I18N.t('text_next_topic_request'));
    }

    function speak(text, onComplete = null) {
        const cleanText = cleanTextForSpeech(text);
        isInterviewerSpeaking = true;
        updateStatus('speaking', I18N.t('status_speaking'));
        console.log('[DEBUG] speak() called, text length:', cleanText.length);

        const skipBtn = document.getElementById('skip-btn');
        if (skipBtn) skipBtn.style.display = 'inline-block';

        const utterance = new SpeechSynthesisUtterance(cleanText);
        configureUtterance(utterance);

        // Ë™≠„Åø‰∏ä„Åí‰∏≠„ÅÆ„É¶„Éº„Ç∂„ÉºÈü≥Â£∞Ââ≤„ÇäËæº„ÅøÊ§úÂá∫„ÇíÈñãÂßã
        if (analyser && interviewRunning && !onComplete) {
            startSpeechInterruptionDetection();
        }

        utterance.onend = () => {
            console.log('[DEBUG] utterance.onend fired, synth.pending:', synth.pending, 'isListening:', isListening);
            stopSpeechInterruptionDetection();
            if(skipBtn) skipBtn.style.display = 'none';
            if (!synth.pending) {
                isInterviewerSpeaking = false;
                isThinking = false;
                if (onComplete) { onComplete(); return; }
                // isListening„ÅåÊó¢„Å´true„Å™„Çâ„ÄÅskipSpeechÁ≠â„ÅßÊó¢„Å´startListening„ÅåÂëº„Å∞„Çå„Å¶„ÅÑ„Çã„ÅÆ„Åß‰∫åÈáçÂëº„Å≥Âá∫„Åó„ÇíÈò≤„Åê
                if (!isListening && !document.querySelector('.status-error') && !document.querySelector('.status-finishing')){
                    startListening();
                }
            }
        };

        utterance.onerror = (e) => {
            // synth.cancel()„Å´„Çà„Çã"interrupted"„ÅØÊ≠£Â∏∏Âãï‰Ωú„Å™„ÅÆ„Åßwarn„É¨„Éô„É´„Å´
            if (e.error === 'interrupted') {
                console.log('[DEBUG] utterance interrupted (skip/cancel)');
            } else {
                console.error('[DEBUG] utterance.onerror:', e.error);
            }
            stopSpeechInterruptionDetection();
        };

        synth.speak(utterance);
        console.log('[DEBUG] synth.speak() called');
    }

    function setupVisualizerCanvas() {
        const canvas = document.getElementById("visualizer");
        canvasCtx = canvas.getContext("2d");
        canvasCtx.fillStyle = '#222'; canvasCtx.fillRect(0, 0, canvas.width, canvas.height);
    }
    async function initAudioContext() {
        if (audioContext) return;
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        audioStream = stream;
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const source = audioContext.createMediaStreamSource(stream);
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 2048; source.connect(analyser);
        dataArray = new Uint8Array(analyser.frequencyBinCount);
        drawVisualizer();
    }
    function drawVisualizer() {
        visualizerFrame = requestAnimationFrame(drawVisualizer);
        if (!analyser) return;
        analyser.getByteTimeDomainData(dataArray);
        const canvas = document.getElementById("visualizer");
        const width = canvas.width; const height = canvas.height;
        canvasCtx.fillStyle = '#222'; canvasCtx.fillRect(0, 0, width, height);
        canvasCtx.lineWidth = 2; canvasCtx.strokeStyle = '#00ffcc'; canvasCtx.beginPath();
        const sliceWidth = width * 1.0 / dataArray.length; let x = 0;
        for (let i = 0; i < dataArray.length; i++) {
            const v = dataArray[i] / 128.0; const y = v * height / 2;
            if (i === 0) canvasCtx.moveTo(x, y); else canvasCtx.lineTo(x, y);
            x += sliceWidth;
        }
        canvasCtx.lineTo(canvas.width, canvas.height / 2); canvasCtx.stroke();
    }
    function toggleVisualizer(isActive) { document.getElementById('visualizer-container').classList.toggle('inactive-visualizer', !isActive); }
    function updateStatus(state, text) {
        const el = document.getElementById('status'); el.className = 'status-box status-' + state; el.innerText = text;
    }
    function addMessage(role, text) {
        const log = document.getElementById('chat-log'); const div = document.createElement('div');
        div.className = `message role-${role}`; div.innerHTML = (role === 'ai' ? 'ü§ñ ' : 'üë§ ') + text;
        log.appendChild(div); log.scrollTop = log.scrollHeight;
    }

    // „Éá„Éê„ÉÉ„Ç∞„É¢„Éº„ÉâÈñ¢ÈÄ£„ÅÆÈñ¢Êï∞
    function toggleDebugMode() {
        debugMode = document.getElementById('debug-mode-toggle').checked;
        const debugBox = document.getElementById('debug-box');
        debugBox.classList.toggle('active', debugMode);
    }

    function addDebugEntry(status, systemPrompt, messages, response = null) {
        try {
            const timestamp = new Date().toLocaleTimeString();
            const historyCount = messages.filter(m => m.role !== 'system').length;

            // promptLog„Å´Ë®òÈå≤ÔºàAI„ÅÆÂøúÁ≠î„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„Å®Á¥ê‰ªò„ÅëÔºâ
            const logEntry = {
                timestamp: timestamp,
                status: status,
                systemPrompt: systemPrompt,
                messages: JSON.parse(JSON.stringify(messages)), // „Éá„Ç£„Éº„Éó„Ç≥„Éî„Éº
                response: response,
                aiResponseIndex: conversationHistory.filter(h => h.role === 'assistant').length
            };
            promptLog.push(logEntry);

            // „Éá„Éê„ÉÉ„Ç∞„É¢„Éº„Éâ„ÅåON„ÅÆÂ†¥Âêà„ÅÆ„ÅøÁîªÈù¢„Å´Ë°®Á§∫
            if (!debugMode) return;

            const debugBox = document.getElementById('debug-box');
            const entry = document.createElement('div');
            entry.className = 'debug-entry';
            entry.id = `debug-entry-${promptLog.length - 1}`;

            // „Éó„É≠„É≥„Éó„Éà„ÇíÁü≠Á∏ÆË°®Á§∫ÔºàÊúÄÂàù„ÅÆ500ÊñáÂ≠óÔºâ
            const shortPrompt = systemPrompt.length > 500
                ? systemPrompt.substring(0, 500) + '...(truncated)'
                : systemPrompt;

            // ÈÄÅ‰ø°„Åô„Çã‰ºöË©±Â±•Ê≠¥„ÇíÊï¥ÂΩ¢
            const historyMessages = messages.filter(m => m.role !== 'system');
            const historyHtml = historyMessages.map(m => {
                const roleLabel = m.role === 'user' ? 'üë§ User' : 'ü§ñ AI';
                const shortContent = m.content.length > 100 ? m.content.substring(0, 100) + '...' : m.content;
                return `<div style="margin: 3px 0; padding: 3px 6px; background: ${m.role === 'user' ? '#3a3a5a' : '#2a4a2a'}; border-radius: 3px;"><strong>${roleLabel}:</strong> ${escapeHtml(shortContent)}</div>`;
            }).join('');

            entry.innerHTML = `
                <div class="debug-timestamp">${timestamp}</div>
                <div class="debug-status">üì° ${status}</div>
                <div style="color: #aaa; margin-top: 8px;">System Prompt („Éà„Éî„ÉÉ„ÇØÁä∂Ê≥ÅÂê´„ÇÄ):</div>
                <div class="debug-prompt">${escapeHtml(shortPrompt)}</div>
                <div style="color: #aaa; margin-top: 8px;">üìú ÈÄÅ‰ø°„Åô„Çã‰ºöË©±Â±•Ê≠¥ (${historyCount}„É°„ÉÉ„Çª„Éº„Ç∏):</div>
                <div class="debug-prompt" style="color: #ff9; max-height: 120px;">${historyHtml || '<em>„Å™„Åó</em>'}</div>
                <div class="debug-response-area"></div>
            `;

            debugBox.insertBefore(entry, debugBox.firstChild);

            // ÊúÄÂ§ß10‰ª∂„Åæ„Åß„Å´Âà∂Èôê
            while (debugBox.children.length > 10) {
                debugBox.removeChild(debugBox.lastChild);
            }
        } catch (e) {
            console.error('Debug entry error:', e);
        }
    }

    function updateDebugEntryResponse(response) {
        try {
            if (!debugMode) return;

            const entryId = `debug-entry-${promptLog.length - 1}`;
            const entry = document.getElementById(entryId);
            if (entry) {
                const statusEl = entry.querySelector('.debug-status');
                if (statusEl) {
                    statusEl.innerHTML = '‚úÖ Response Received';
                    statusEl.style.color = '#98fb98';
                }
                const responseArea = entry.querySelector('.debug-response-area');
                if (responseArea && response) {
                    responseArea.innerHTML = `
                        <div style="color: #aaa; margin-top: 8px;">Response:</div>
                        <div class="debug-prompt" style="color: #98fb98;">${escapeHtml(response.substring(0, 300))}${response.length > 300 ? '...' : ''}</div>
                    `;
                }
            }
        } catch (e) {
            console.error('Debug update error:', e);
        }
    }

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
</script>

</body>
</html>