<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Interviewer (Running - v12)</title>
    <style>
        body { font-family: "Helvetica Neue", Arial, sans-serif; max-width: 900px; margin: 0 auto; padding: 20px; background-color: #f0f2f5; color: #333; position: relative; }
        .container { background: white; padding: 30px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); }
        h2 { text-align: center; color: #444; margin-bottom: 5px; }
        .subtitle { text-align: center; color: #777; font-size: 0.9em; margin-bottom: 20px; }
        
        #timer {
            position: absolute; top: 20px; right: 20px;
            font-size: 1.5em; font-weight: bold; color: #555;
            background: #fff; padding: 5px 15px; border-radius: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .status-box { padding: 12px; margin-bottom: 10px; text-align: center; font-weight: bold; border-radius: 8px; transition: all 0.3s; }
        .status-idle { background-color: #e9ecef; color: #6c757d; }
        .status-listening { background-color: #ffebee; color: #c62828; border: 1px solid #ffcdd2; animation: pulse 2s infinite; }
        .status-thinking { background-color: #e3f2fd; color: #1565c0; border: 1px solid #bbdefb; }
        .status-speaking { background-color: #e8f5e9; color: #2e7d32; border: 1px solid #c8e6c9; }
        .status-finishing { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .status-error { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }

        #visualizer-container { height: 60px; background-color: #222; border-radius: 8px; margin-bottom: 20px; display: flex; overflow: hidden; }
        canvas { display: block; width: 100%; height: 100%; }
        .inactive-visualizer { opacity: 0.3; filter: grayscale(100%); }
        
        .content-wrapper { display: flex; gap: 20px; flex-wrap: wrap; }
        .chat-section { flex: 1; min-width: 300px; }
        .summary-section { flex: 1; min-width: 300px; display: none; }
        #chat-log { height: 400px; overflow-y: auto; border: 1px solid #dee2e6; padding: 20px; background: #fafafa; border-radius: 8px; }
        
        .message { margin-bottom: 15px; padding: 12px 16px; border-radius: 12px; max-width: 90%; line-height: 1.5; }
        .role-user { background-color: #007bff; color: white; margin-left: auto; border-bottom-right-radius: 2px; }
        .role-ai { background-color: #fff; border: 1px solid #e9ecef; margin-right: auto; border-bottom-left-radius: 2px; }
        
        #summary-box { height: 350px; overflow-y: auto; border: 2px solid #28a745; padding: 20px; background: #fff; border-radius: 8px; line-height: 1.8; white-space: pre-wrap; margin-bottom: 10px; }
        .summary-title { font-weight: bold; color: #28a745; margin-bottom: 10px; }

        /* --- ãƒœã‚¿ãƒ³ã‚¨ãƒªã‚¢ã®ã‚¹ã‚¿ã‚¤ãƒ« --- */
        .controls { margin-top: 20px; }
        
        /* å…±é€šãƒœã‚¿ãƒ³ã‚¹ã‚¿ã‚¤ãƒ« */
        .btn { 
            padding: 15px 30px; font-size: 1.1em; font-weight: bold; 
            cursor: pointer; border: none; border-radius: 50px; 
            color: white; transition: all 0.2s; width: 100%;
        }
        .btn:hover { opacity: 0.9; transform: translateY(-1px); }
        .btn:active { transform: translateY(1px); }

        .btn-start { background-color: #007bff; max-width: 400px; display: block; margin: 0 auto; }
        .btn-abort { background-color: #dc3545; }
        .btn-finish { background-color: #28a745; }
        .btn-back { background-color: #6c757d; max-width: 400px; display: block; margin: 0 auto; }

        /* å®Ÿè¡Œä¸­ã®ãƒœã‚¿ãƒ³ã‚³ãƒ³ãƒ†ãƒŠï¼ˆæ¨ªä¸¦ã³ï¼‰ */
        .running-controls {
            display: flex; gap: 15px; justify-content: center;
            width: 100%; max-width: 600px; margin: 0 auto;
        }
        .running-controls button { flex: 1; }

        /* ã‚¹ã‚­ãƒƒãƒ—ãƒœã‚¿ãƒ³ */
        #skip-btn-container { text-align: center; margin-bottom: 15px; height: 40px; }
        #skip-btn {
            background-color: #6c757d; color: white; border: none; 
            padding: 8px 25px; border-radius: 30px; font-weight: bold; font-size: 0.9em;
            cursor: pointer; display: none;
        }
        #skip-btn:hover { background-color: #5a6268; }

        .copy-btn { width: 100%; padding: 10px; background-color: #6c757d; color: white; border: none; border-radius: 5px; cursor: pointer; }
        .copy-btn:disabled, .btn-back:disabled { background-color: #adb5bd; cursor: not-allowed; opacity: 0.7; }

        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.6; } 100% { opacity: 1; } }

        /* ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰ */
        .debug-toggle-container {
            display: flex;
            justify-content: flex-end;
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid #eee;
        }
        .debug-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.85em;
            color: #666;
            cursor: pointer;
        }
        .debug-toggle input[type="checkbox"] {
            width: 16px;
            height: 16px;
        }
        .debug-box {
            display: none;
            margin-top: 15px;
            padding: 15px;
            background: #1e1e1e;
            border-radius: 8px;
            color: #00ff00;
            font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
            font-size: 0.8em;
            max-height: 300px;
            overflow-y: auto;
        }
        .debug-box.active { display: block; }
        .debug-entry {
            margin-bottom: 12px;
            padding-bottom: 12px;
            border-bottom: 1px solid #333;
        }
        .debug-entry:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }
        .debug-timestamp {
            color: #888;
            font-size: 0.9em;
            margin-bottom: 4px;
        }
        .debug-status {
            color: #ffd700;
            font-weight: bold;
            margin-bottom: 4px;
        }
        .debug-prompt {
            white-space: pre-wrap;
            word-break: break-word;
            color: #7fdbff;
            max-height: 150px;
            overflow-y: auto;
            padding: 8px;
            background: #2a2a2a;
            border-radius: 4px;
            margin-top: 4px;
        }
        .debug-history {
            color: #ff6b6b;
            margin-top: 4px;
        }
    </style>
</head>
<body>

<div id="timer">00:00</div>

<div class="container">
    <h2 id="page-title">ã‚¤ãƒ³ã‚¿ãƒ“ãƒ¥ãƒ¼</h2>
    <div class="subtitle" id="page-topics">èª­ã¿è¾¼ã¿ä¸­...</div>
    <div id="status" class="status-box status-idle">å¾…æ©Ÿä¸­</div>
    
    <div id="visualizer-container" class="inactive-visualizer">
        <canvas id="visualizer" width="600" height="100"></canvas>
    </div>

    <div class="content-wrapper">
        <div class="chat-section"><div id="chat-log"></div></div>
        <div class="summary-section" id="summary-section">
            <div class="summary-title">ğŸ“ ã‚¤ãƒ³ã‚¿ãƒ“ãƒ¥ãƒ¼çµæœã‚µãƒãƒªãƒ¼</div>
            <div id="summary-box">ã“ã“ã«çµæœãŒè¡¨ç¤ºã•ã‚Œã¾ã™...</div>
            <button id="copy-btn" class="copy-btn" onclick="copySummary()" disabled>ğŸ“‹ ã‚µãƒãƒªãƒ¼ã‚’ã‚³ãƒ”ãƒ¼</button>
        </div>
    </div>

    <div class="controls">
        <div id="skip-btn-container">
            <button id="skip-btn" onclick="skipSpeech()">â© è©±ã™ã®ã‚’ã‚„ã‚ã¦èã (Skip)</button>
        </div>

        <div id="ctrl-idle">
            <button class="btn btn-start" onclick="startInterview()">ã‚¤ãƒ³ã‚¿ãƒ“ãƒ¥ãƒ¼é–‹å§‹</button>
        </div>

        <div id="ctrl-running" class="running-controls" style="display:none;">
            <button class="btn btn-abort" onclick="abortInterview()">ä¸­æ­¢ã™ã‚‹<br><span style="font-size:0.7em; font-weight:normal">(ä¿å­˜ã•ã‚Œã¾ã›ã‚“)</span></button>
            <button class="btn btn-finish" onclick="forceFinish()">çµ‚äº†ã™ã‚‹<br><span style="font-size:0.7em; font-weight:normal">(ã‚µãƒãƒªãƒ¼ç”Ÿæˆ)</span></button>
        </div>

        <div id="ctrl-finished" style="display:none;">
            <button id="back-btn" class="btn btn-back" onclick="window.location.href='index.html'" disabled>è¨­å®šç”»é¢ã«æˆ»ã‚‹</button>
        </div>
    </div>

    <!-- ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰ -->
    <div class="debug-toggle-container">
        <label class="debug-toggle">
            <input type="checkbox" id="debug-mode-toggle" onchange="toggleDebugMode()">
            <span>ğŸ› Debug Mode</span>
        </label>
    </div>
    <div id="debug-box" class="debug-box">
        <div style="color: #888; margin-bottom: 10px;">APIã‚³ãƒ¼ãƒ«ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆæƒ…å ±ãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™</div>
    </div>
</div>

<script>
    const DB_NAME = "InterviewDB";
    const DB_VERSION = 1;
    const STORE_NAME = "archives";

    let CONFIG = {}; 
    let recognition;
    let isInterviewerSpeaking = false; 
    let isThinking = false; 
    let conversationHistory = [];      
    let synth = window.speechSynthesis;
    let audioContext, analyser, dataArray, canvasCtx, visualizerFrame;
    let availableVoices = [];
    
    let timerInterval;
    let startTime;

    let currentTopicIndex = 0;

    // ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰é–¢é€£
    let debugMode = false;
    let promptLog = [];  // å„APIã‚³ãƒ¼ãƒ«ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆæƒ…å ±ã‚’è¨˜éŒ² 

    window.speechSynthesis.onvoiceschanged = () => { availableVoices = window.speechSynthesis.getVoices(); };

    window.onload = () => {
        const storedConfig = localStorage.getItem('interviewConfig');
        if (storedConfig) {
            CONFIG = JSON.parse(storedConfig);
        } else {
            alert("è¨­å®šç”»é¢ã‹ã‚‰èµ·å‹•ã—ã¦ãã ã•ã„ã€‚");
            window.location.href = 'index.html';
            return;
        }

        document.getElementById('page-title').innerText = CONFIG.title;
        document.getElementById('page-topics').innerText = "èããŸã„ã“ã¨: " + CONFIG.topics.length + "é …ç›®";

        setupRecognition();
        setupVisualizerCanvas();
        setButtonState("IDLE");
    };

    function setButtonState(state) {
        document.getElementById('ctrl-idle').style.display = 'none';
        document.getElementById('ctrl-running').style.display = 'none';
        document.getElementById('ctrl-finished').style.display = 'none';
        document.getElementById('skip-btn').style.display = 'none';

        if (state === "IDLE") {
            document.getElementById('ctrl-idle').style.display = 'block';
        } else if (state === "RUNNING") {
            document.getElementById('ctrl-running').style.display = 'flex';
        } else if (state === "FINISHED") {
            document.getElementById('ctrl-finished').style.display = 'block';
        }
    }

    function abortInterview() {
        if (confirm("ã‚¤ãƒ³ã‚¿ãƒ“ãƒ¥ãƒ¼ã‚’ä¸­æ­¢ã—ã¾ã™ã‹ï¼Ÿ\nï¼ˆå†…å®¹ã¯ä¿å­˜ã•ã‚Œã¾ã›ã‚“ï¼‰")) {
            stopRecognition();
            clearInterval(timerInterval);
            window.location.href = 'index.html';
        }
    }

    function forceFinish() {
        if (confirm("ç¾åœ¨ã¾ã§ã®å†…å®¹ã§ã‚¤ãƒ³ã‚¿ãƒ“ãƒ¥ãƒ¼ã‚’çµ‚äº†ã—ã€ã‚µãƒãƒªãƒ¼ã‚’ä½œæˆã—ã¾ã™ã‹ï¼Ÿ")) {
            stopTimer();
            stopRecognition();
            updateStatus('finishing', 'çµ‚äº†å‡¦ç†ä¸­... ã‚µãƒãƒªãƒ¼ã‚’ä½œæˆã—ã¾ã™');
            document.getElementById('ctrl-running').style.display = 'none'; 
            generateSummary();
        }
    }

    function startTimer() {
        startTime = Date.now();
        clearInterval(timerInterval);
        timerInterval = setInterval(() => {
            const diff = Date.now() - startTime;
            const mins = Math.floor(diff / 60000);
            const secs = Math.floor((diff % 60000) / 1000);
            document.getElementById('timer').innerText = 
                (mins < 10 ? "0" : "") + mins + ":" + (secs < 10 ? "0" : "") + secs;
        }, 1000);
    }

    function stopTimer() {
        clearInterval(timerInterval);
    }

    function skipSpeech() {
        if (synth.speaking || synth.pending) {
            synth.cancel(); 
            isInterviewerSpeaking = false;
            isThinking = false;
            document.getElementById('skip-btn').style.display = 'none';
            
            if (!document.querySelector('.status-finishing')) {
                updateStatus('listening', 'èã„ã¦ã„ã¾ã™...'); 
                toggleVisualizer(true);
                try { recognition.start(); } catch(e) { console.log("Mic forced active"); }
            }
        }
    }

    async function startInterview() {
        if (!CONFIG.apiKey) return alert("APIã‚­ãƒ¼ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“");

        conversationHistory = [];
        currentTopicIndex = 0;
        promptLog = [];  // ãƒ‡ãƒãƒƒã‚°ç”¨ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆå±¥æ­´ã‚’ãƒªã‚»ãƒƒãƒˆ

        document.getElementById('chat-log').innerHTML = '';
        document.getElementById('summary-section').style.display = 'none';
        document.getElementById('summary-box').innerText = '...';
        document.getElementById('debug-box').innerHTML = '<div style="color: #888; margin-bottom: 10px;">APIã‚³ãƒ¼ãƒ«ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆæƒ…å ±ãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™</div>';

        await initAudioContext();
        setButtonState("RUNNING");
        startTimer();
        
        try { recognition.start(); } catch(e) {}

        const intro = "ã“ã‚“ã«ã¡ã¯ã€‚ã‚¤ãƒ³ã‚¿ãƒ“ãƒ¥ãƒ¼ã‚’å§‹ã‚ã¾ã™ã€‚ã¾ãšã¯è‡ªå·±ç´¹ä»‹ã‚’ãŠé¡˜ã„ã—ã¾ã™ã€‚";
        addMessage('ai', intro);
        conversationHistory.push({ role: "assistant", content: intro });
        speak(intro);
    }

    function stopRecognition() {
        isInterviewerSpeaking = false; 
        isThinking = false;
        if(recognition) recognition.stop();
        synth.cancel(); 
        toggleVisualizer(false);
    }

    async function processUserResponse(userText) {
        console.log('[DEBUG] processUserResponse called with:', userText.substring(0, 50));
        isThinking = true;
        updateStatus('thinking', 'AIãŒè€ƒãˆã¦ã„ã¾ã™ (Groq)...');

        conversationHistory.push({ role: "user", content: userText });

        // çµ‚äº†å¸Œæœ›ãƒã‚§ãƒƒã‚¯
        let forceEnd = false;
        if (userText.includes("ã‚„ã‚ã¦") || userText.includes("çµ‚äº†ã—ã¦") || userText.includes("ã‚¹ãƒˆãƒƒãƒ—")) {
            forceEnd = true;
        }

        try {
            const systemPrompt = buildDynamicPrompt(forceEnd);
            const rawAiText = await callGroqAPI(conversationHistory, systemPrompt);

            // [[NEXT]]ãƒãƒ¼ã‚«ãƒ¼ã‚’æ¤œå‡ºã—ã¦ãƒˆãƒ”ãƒƒã‚¯ç§»è¡Œ
            let aiText = rawAiText;
            if (rawAiText.includes("[[NEXT]]")) {
                aiText = rawAiText.replace("[[NEXT]]", "").trim();
                currentTopicIndex++;
                console.log(`Topic advanced to: ${currentTopicIndex}`);
            }

            addMessage('ai', aiText);
            conversationHistory.push({ role: "assistant", content: aiText });

            if (aiText.includes("çµ‚äº†ã—ã¾ã™") || aiText.includes("çµ‚ã‚ã‚Šã¾ã™")) {
                stopTimer();
                updateStatus('finishing', 'æŒ¨æ‹¶ã®èª­ã¿ä¸Šã’ä¸­...');

                speak(aiText, () => {
                    updateStatus('finishing', 'ã‚µãƒãƒªãƒ¼ä½œæˆä¸­...');
                    stopRecognition();
                    generateSummary();
                });
            } else {
                speak(aiText);
            }

        } catch (error) {
            console.error(error);
            addMessage('ai', `<span class="error-msg">${error.message}</span>`);
            speak("ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚");
            updateStatus('error', 'ã‚¨ãƒ©ãƒ¼');
            isThinking = false;
        }
    }

    function buildDynamicPrompt(forceEnd = false) {
        const contextText = CONFIG.context ? `\n# Pre-knowledge / Background Context\n${CONFIG.context}\n` : "";

        // ãƒˆãƒ”ãƒƒã‚¯ä¸€è¦§ã¨ç¾åœ¨ä½ç½®
        const topicsList = CONFIG.topics.map((t, i) => {
            if (i < currentTopicIndex) return `  âœ“ ${t} (å®Œäº†)`;
            if (i === currentTopicIndex) return `  â–¶ ${t} (ç¾åœ¨)`;
            return `  â—‹ ${t}`;
        }).join('\n');

        const currentTopic = CONFIG.topics[currentTopicIndex] || null;
        const remainingCount = CONFIG.topics.length - currentTopicIndex;
        const isLastTopic = currentTopicIndex >= CONFIG.topics.length - 1;
        const allDone = currentTopicIndex >= CONFIG.topics.length;

        // çŠ¶æ³ã«å¿œã˜ãŸæŒ‡ç¤º
        let situationInstruction = "";
        if (forceEnd) {
            situationInstruction = `
## ç¾åœ¨ã®çŠ¶æ³: ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒçµ‚äº†ã‚’å¸Œæœ›
ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒçµ‚äº†ã‚’å¸Œæœ›ã—ã¦ã„ã¾ã™ã€‚æ„Ÿè¬ã‚’ä¼ãˆã€ã€Œãã‚Œã§ã¯ã‚¤ãƒ³ã‚¿ãƒ“ãƒ¥ãƒ¼ã‚’çµ‚äº†ã—ã¾ã™ã€ã¨è¨€ã£ã¦ç· ã‚ããã£ã¦ãã ã•ã„ã€‚`;
        } else if (allDone) {
            situationInstruction = `
## ç¾åœ¨ã®çŠ¶æ³: å…¨ãƒˆãƒ”ãƒƒã‚¯å®Œäº†
å…¨ã¦ã®ãƒˆãƒ”ãƒƒã‚¯ãŒçµ‚ã‚ã‚Šã¾ã—ãŸã€‚ã€Œæœ€å¾Œã«ä½•ã‹è¨€ã„æ®‹ã—ãŸã“ã¨ã¯ã‚ã‚Šã¾ã™ã‹ï¼Ÿã€ã¨èã„ã¦ãã ã•ã„ã€‚
ç›¸æ‰‹ãŒç‰¹ã«ãªã„ã¨è¨€ã£ãŸã‚‰ã€æ„Ÿè¬ã‚’ä¼ãˆã€Œãã‚Œã§ã¯ã‚¤ãƒ³ã‚¿ãƒ“ãƒ¥ãƒ¼ã‚’çµ‚äº†ã—ã¾ã™ã€ã¨ç· ã‚ããã£ã¦ãã ã•ã„ã€‚`;
        } else {
            const depthHint = CONFIG.depth === "deep"
                ? "ï¼ˆã˜ã£ãã‚Šæ¢æ±‚ãƒ¢ãƒ¼ãƒ‰ï¼šå„ãƒˆãƒ”ãƒƒã‚¯4ã€œ6å›ç¨‹åº¦ã®ã‚„ã‚Šå–ã‚Šã‚’ç›®å®‰ã«ã€ã—ã£ã‹ã‚Šæ·±æ˜ã‚Šã—ã¦ãã ã•ã„ï¼‰"
                : "ï¼ˆæ¨™æº–ãƒ¢ãƒ¼ãƒ‰ï¼šå„ãƒˆãƒ”ãƒƒã‚¯2ã€œ4å›ç¨‹åº¦ã®ã‚„ã‚Šå–ã‚Šã‚’ç›®å®‰ã«ã€ãƒ†ãƒ³ãƒã‚ˆãé€²ã‚ã¦ãã ã•ã„ï¼‰";
            situationInstruction = `
## ç¾åœ¨ã®çŠ¶æ³
- ç¾åœ¨ã®ãƒˆãƒ”ãƒƒã‚¯: ã€Œ${currentTopic}ã€
- æ®‹ã‚Šãƒˆãƒ”ãƒƒã‚¯æ•°: ${remainingCount}å€‹${isLastTopic ? 'ï¼ˆã“ã‚ŒãŒæœ€å¾Œã®ãƒˆãƒ”ãƒƒã‚¯ï¼‰' : ''}
- ã‚¤ãƒ³ã‚¿ãƒ“ãƒ¥ãƒ¼ã‚¹ã‚¿ã‚¤ãƒ«: ${depthHint}

## ãƒˆãƒ”ãƒƒã‚¯ä¸€è¦§
${topicsList}`;
        }

        return `
# Persona
${CONFIG.persona}
${contextText}
${situationInstruction}

# ã‚¤ãƒ³ã‚¿ãƒ“ãƒ¥ãƒ¼é€²è¡Œãƒ«ãƒ¼ãƒ«

## å¯¾è©±ã®è³ªã«å¿œã˜ãŸå¯¾å¿œï¼ˆé‡è¦ï¼ï¼‰

### å›ç­”ãŒçŸ­ã„ãƒ»ã‚ã£ã•ã‚Šã—ã¦ã„ã‚‹å ´åˆ
ä»¥ä¸‹ã®ã„ãšã‚Œã‹ã§**ã‚‚ã†å°‘ã—å¼•ãå‡ºã—ã¦**ãã ã•ã„ï¼š
- ã€Œã‚‚ã†å°‘ã—è©³ã—ãèã‹ã›ã¦ã‚‚ã‚‰ãˆã¾ã™ã‹ï¼Ÿã€
- ã€Œãã‚Œã£ã¦å…·ä½“çš„ã«ã¯ã©ã†ã„ã†ã“ã¨ã§ã™ã‹ï¼Ÿã€
- ã€Œä¾‹ãˆã°ã©ã‚“ãªå ´é¢ã§ãã†æ„Ÿã˜ã¾ã—ãŸã‹ï¼Ÿã€
- ã€Œã€œã¨ã„ã†ç†è§£ã§åˆã£ã¦ã¾ã™ã‹ï¼Ÿã€ã¨åˆ¥ã®è¨€è‘‰ã§ç¢ºèª
- æ¯”å–©ã‚„ä¾‹ãˆè©±ã§ã€Œã¤ã¾ã‚Šã€œã¿ãŸã„ãªæ„Ÿã˜ã§ã™ã‹ï¼Ÿã€

### å›ç­”ãŒæ›–æ˜§ãƒ»æŠ½è±¡çš„ãªå ´åˆ
- ã€Œä¸€ç•ªå°è±¡ã«æ®‹ã£ã¦ã„ã‚‹ã‚¨ãƒ”ã‚½ãƒ¼ãƒ‰ã‚’æ•™ãˆã¦ãã ã•ã„ã€
- ã€Œæ™‚ç³»åˆ—ã§è¨€ã†ã¨ã€æœ€åˆã«ä½•ãŒèµ·ãã¾ã—ãŸã‹ï¼Ÿã€
- ã€Œæ•°å­—ã§è¨€ã†ã¨ã©ã®ãã‚‰ã„ã§ã™ã‹ï¼Ÿã€

### å›ç­”ãŒå……å®Ÿã—ã¦ã„ã‚‹ãƒ»ç››ã‚Šä¸ŠãŒã£ã¦ã„ã‚‹å ´åˆ
ã©ã‚“ã©ã‚“æ·±æ˜ã‚Šã—ã¦ãã ã•ã„ï¼š
- æ„Ÿæƒ…ã‚’æ˜ã‚‹ï¼šã€Œãã®æ™‚ã©ã‚“ãªæ°—æŒã¡ã§ã—ãŸã‹ï¼Ÿã€
- ç†ç”±ã‚’æ˜ã‚‹ï¼šã€Œãªãœãã†æ€ã£ãŸã‚“ã§ã™ã‹ï¼Ÿã€
- å½±éŸ¿ã‚’æ˜ã‚‹ï¼šã€Œãã‚ŒãŒä»Šã«ã©ã†ç¹‹ãŒã£ã¦ã„ã¾ã™ã‹ï¼Ÿã€
- æ„å¤–ãªè§’åº¦ï¼šã€Œé€†ã«ã€œã ã£ãŸã‚‰ã©ã†ã§ã—ãŸã‹ï¼Ÿã€

### æ¬¡ã®ãƒˆãƒ”ãƒƒã‚¯ã«ç§»ã‚‹ã‚¿ã‚¤ãƒŸãƒ³ã‚°
ä»¥ä¸‹ã®å ´åˆã«æ¬¡ã¸é€²ã‚“ã§ãã ã•ã„ï¼š
- åŒã˜è©±ãŒç¹°ã‚Šè¿”ã•ã‚Œã¦ã„ã‚‹
- ç›¸æ‰‹ãŒã€Œç‰¹ã«ãªã„ã§ã™ã€ã€Œãã®ãã‚‰ã„ã§ã™ã‹ã­ã€ã¨è¨€ã£ãŸ
- ååˆ†ãªæ·±ã•ï¼ˆç†ç”±ã€ã‚¨ãƒ”ã‚½ãƒ¼ãƒ‰ã€æ„Ÿæƒ…ï¼‰ãŒèã‘ãŸ
- 3å›ä»¥ä¸Šæ·±æ˜ã‚Šã—ã¦ã‚‚æ–°ã—ã„æƒ…å ±ãŒå‡ºãªã„

## ãƒˆãƒ”ãƒƒã‚¯ç§»è¡Œã®æ–¹æ³•
æ¬¡ã®ãƒˆãƒ”ãƒƒã‚¯ã«ç§»ã‚‹æ™‚ã¯ã€å›ç­”ã®**æœ«å°¾**ã«å¿…ãš \`[[NEXT]]\` ã‚’ä»˜ã‘ã¦ãã ã•ã„ã€‚
ä¾‹: ã€Œãªã‚‹ã»ã©ã€ã‚ˆãåˆ†ã‹ã‚Šã¾ã—ãŸã€‚ã§ã¯æ¬¡ã«ã€ã€œã«ã¤ã„ã¦ãŠèãã—ãŸã„ã®ã§ã™ãŒ...ï¼Ÿ[[NEXT]]ã€

## åŸºæœ¬ãƒ«ãƒ¼ãƒ«
1. **ã‚ªã‚¦ãƒ è¿”ã—ç¦æ­¢** - ã€Œã€œã¨ã„ã†ã“ã¨ã§ã™ã­ã€ã€Œã€œãªã‚“ã§ã™ã­ã€ã¯ä½¿ã‚ãªã„
2. **ç›¸æ§Œã‹ã‚‰å§‹ã‚ã‚‹** - ã€Œãªã‚‹ã»ã©ã€ã€ã€Œã¸ã‡ã€œã€ã€ã€Œã‚ãã€ã€ãªã©ï¼ˆæ¯å›é•ã†ã‚‚ã®ã‚’ï¼‰
3. **ã™ãè³ªå•** - é•·ã„å‰ç½®ããªã—ã§è³ªå•ã¸
4. **å¿…ãšè³ªå•ã§çµ‚ã‚ã‚‹** - ç™ºè¨€ã®æœ€å¾Œã¯è³ªå•å½¢
5. **çµ‚äº†ç¦æ­¢** - çµ‚äº†ã™ã‚‹æ™‚ä»¥å¤–ã¯ã€Œçµ‚äº†ã—ã¾ã™ã€ã¨è¨€ã‚ãªã„
`;
    }

    // --- API Call (Token optimization) ---
    async function callGroqAPI(history, systemPrompt, customTemp = 0.7, customMaxTokens = 1024, callType = 'interview') {
        const url = "https://api.groq.com/openai/v1/chat/completions";

        // â˜…ãƒˆãƒ¼ã‚¯ãƒ³ç¯€ç´„ãƒ­ã‚¸ãƒƒã‚¯: å±¥æ­´ã¯ç›´è¿‘ã®10ä»¶ï¼ˆ5å¾€å¾©ï¼‰ã®ã¿é€ä¿¡ã™ã‚‹
        const MAX_HISTORY = 10;
        const recentHistory = history.length > MAX_HISTORY ? history.slice(-MAX_HISTORY) : history;

        const messages = [{ role: "system", content: systemPrompt }, ...recentHistory];

        const payload = {
            model: CONFIG.modelName || "llama-3.1-8b-instant",
            messages: messages,
            temperature: customTemp,
            max_tokens: customMaxTokens
        };

        // ãƒ‡ãƒãƒƒã‚°: ãƒªã‚¯ã‚¨ã‚¹ãƒˆé€ä¿¡å‰ã«è¨˜éŒ²
        addDebugEntry(`${callType} - Sending Request`, systemPrompt, messages);
        console.log('[DEBUG] API Request starting...', { model: payload.model, messageCount: messages.length });

        // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆä»˜ãfetchï¼ˆ30ç§’ï¼‰
        const controller = new AbortController();
        const timeoutId = setTimeout(() => {
            controller.abort();
            console.log('[DEBUG] API Request timeout after 30s');
        }, 30000);

        try {
            const response = await fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${CONFIG.apiKey}`
                },
                body: JSON.stringify(payload),
                signal: controller.signal
            });

            clearTimeout(timeoutId);
            console.log('[DEBUG] API Response received, status:', response.status);

            if (!response.ok) {
                const err = await response.json().catch(() => ({}));
                // Rate Limitã‚¨ãƒ©ãƒ¼ã®å ´åˆã¯ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«åˆ†ã‹ã‚Šã‚„ã™ãè¡¨ç¤º
                if (response.status === 429) {
                    throw new Error("Rate Limit Exceeded: 1æ—¥ã®åˆ©ç”¨åˆ¶é™ã«é”ã—ã¾ã—ãŸã€‚æ™‚é–“ã‚’ãŠã„ã¦è©¦ã—ã¦ãã ã•ã„ã€‚");
                }
                throw new Error(`Groq API Error: ${err.error?.message || response.statusText}`);
            }

            const data = await response.json();
            console.log('[DEBUG] API Response parsed successfully');
            const responseText = data.choices[0].message.content;

            // ãƒ‡ãƒãƒƒã‚°: ãƒ¬ã‚¹ãƒãƒ³ã‚¹å—ä¿¡å¾Œã«è¨˜éŒ²ã‚’æ›´æ–°
            if (promptLog.length > 0) {
                promptLog[promptLog.length - 1].response = responseText;
                promptLog[promptLog.length - 1].status = `${callType} - Response Received`;
            }

            // ãƒ‡ãƒãƒƒã‚°ç”»é¢ã‚‚æ›´æ–°
            updateDebugEntryResponse(responseText);

            return responseText;
        } catch (err) {
            clearTimeout(timeoutId);
            if (err.name === 'AbortError') {
                throw new Error('APIå‘¼ã³å‡ºã—ãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸï¼ˆ30ç§’ï¼‰ã€‚å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚');
            }
            throw err;
        }
    }

    async function generateSummary() {
        const summarySection = document.getElementById('summary-section');
        summarySection.style.display = 'block';
        const summaryBox = document.getElementById('summary-box');
        summaryBox.innerText = "é•·æ–‡ã‚µãƒãƒªãƒ¼ç”Ÿæˆä¸­...";

        const historyText = conversationHistory.map(item => `${item.role}: ${item.content}`).join("\n");
        const prompt = `ä»¥ä¸‹ã®ãƒ­ã‚°ã‚’å…ƒã«ã€è©³ç´°ãªãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ã‚¿ãƒªãƒ¼è¨˜äº‹ã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚\n\nã€ãƒ­ã‚°ã€‘\n${historyText}`;
        
        try {
            // ã‚µãƒãƒªãƒ¼ç”Ÿæˆæ™‚ã¯å±¥æ­´ã‚’é€ã‚‰ãšã€ãƒ†ã‚­ã‚¹ãƒˆåŒ–ã—ã¦é€ã‚‹ï¼ˆã“ã‚Œã¯å¤‰ãˆãªã„ï¼‰
            // Summaryæ™‚ã¯ãƒˆãƒ¼ã‚¯ãƒ³æ¶ˆè²»ãŒå¤šã„ãŒ1å›ã ã‘ãªã®ã§è¨±å®¹ã™ã‚‹ã€‚
            const summaryText = await callGroqAPI([{ role: "user", content: prompt }], "ã‚ãªãŸã¯å„ªç§€ãªãƒ©ã‚¤ã‚¿ãƒ¼ã§ã™ã€‚", 0.7, 4096, 'summary');
            summaryBox.innerText = summaryText;
            updateStatus('idle', 'å®Œäº†');
            setButtonState("FINISHED");
            // ã‚µãƒãƒªãƒ¼å®Œäº†å¾Œã«ãƒœã‚¿ãƒ³ã‚’æœ‰åŠ¹åŒ–
            document.getElementById('copy-btn').disabled = false;
            document.getElementById('back-btn').disabled = false;
            await saveToDB(summaryText);
        } catch (error) {
            summaryBox.innerHTML = `<span style="color:red;">${error.message}</span>`;
            updateStatus('error', 'ã‚¨ãƒ©ãƒ¼');
            // ã‚¨ãƒ©ãƒ¼æ™‚ã‚‚æˆ»ã‚‹ãƒœã‚¿ãƒ³ã¯æœ‰åŠ¹åŒ–
            document.getElementById('back-btn').disabled = false;
            setButtonState("FINISHED");
        }
    }

    function openDB() {
        return new Promise((r, j) => {
            const req = indexedDB.open(DB_NAME, DB_VERSION);
            req.onupgradeneeded = (e) => { 
                const db = e.target.result; 
                if (!db.objectStoreNames.contains(STORE_NAME)) db.createObjectStore(STORE_NAME, { keyPath: "id" });
            };
            req.onsuccess = (e) => r(e.target.result);
            req.onerror = (e) => j(e.target.error);
        });
    }

    async function saveToDB(summaryText) {
        try {
            const db = await openDB();
            const tx = db.transaction(STORE_NAME, "readwrite");
            const store = tx.objectStore(STORE_NAME);
            const record = {
                id: Date.now(),
                title: CONFIG.title,
                date: new Date().toLocaleString(),
                topics: CONFIG.topics,
                history: conversationHistory,
                summary: summaryText,
                // ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆå±¥æ­´ã‚’ä¿å­˜ï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
                promptLog: promptLog,
                // è¨­å®šæƒ…å ±ã‚‚ä¿å­˜
                settings: {
                    modelName: CONFIG.modelName || "llama-3.1-8b-instant",
                    context: CONFIG.context || "",
                    personaType: CONFIG.personaType || "listener",
                    persona: CONFIG.persona || "",
                    voiceName: CONFIG.voiceName || "",
                    rate: CONFIG.rate || 1.3,
                    depth: CONFIG.depth || "standard"
                }
            };
            store.add(record);
        } catch (e) { console.error("DB Error:", e); }
    }

    function copySummary() {
        const text = document.getElementById('summary-box').innerText;
        navigator.clipboard.writeText(text).then(() => alert("ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸï¼"));
    }

    function cleanTextForSpeech(text) { return text.replace(/[\*#_`~]/g, ''); }

    function configureUtterance(utterance) {
        utterance.rate = CONFIG.rate; utterance.volume = 1.0; utterance.pitch = 1.0; 
        if (availableVoices.length === 0) availableVoices = window.speechSynthesis.getVoices();
        const selectedVoice = availableVoices.find(v => v.name === CONFIG.voiceName);
        if (selectedVoice) utterance.voice = selectedVoice;
    }
    
    function setupRecognition() {
        if (!('webkitSpeechRecognition' in window)) return alert("Chromeãƒ–ãƒ©ã‚¦ã‚¶ã§é–‹ã„ã¦ãã ã•ã„");
        recognition = new webkitSpeechRecognition();
        recognition.lang = 'ja-JP'; recognition.continuous = true; recognition.interimResults = false;
        recognition.onstart = () => { updateStatus('listening', 'èã„ã¦ã„ã¾ã™...'); toggleVisualizer(true); };
        recognition.onresult = (event) => {
            const transcript = event.results[event.results.length - 1][0].transcript.trim();
            console.log('[DEBUG] Speech recognized:', transcript, { isInterviewerSpeaking, isThinking });
            if (!transcript) return;
            if (isInterviewerSpeaking || isThinking) {
                console.log('[DEBUG] Ignoring speech - AI is speaking or thinking');
                return;
            }
            addMessage('user', transcript);
            processUserResponse(transcript);
        };
        recognition.onend = () => {
            console.log('[DEBUG] recognition.onend fired, isInterviewerSpeaking:', isInterviewerSpeaking, 'isThinking:', isThinking);
            toggleVisualizer(false);
            // éŸ³å£°èªè­˜ãŒäºˆæœŸã›ãšçµ‚äº†ã—ãŸå ´åˆã€å†èµ·å‹•ã‚’è©¦ã¿ã‚‹
            if (!isInterviewerSpeaking && !isThinking && !document.querySelector('.status-error') && !document.querySelector('.status-finishing') && !document.querySelector('.status-idle')) {
                console.log('[DEBUG] Attempting to restart recognition...');
                setTimeout(() => {
                    try {
                        recognition.start();
                        console.log('[DEBUG] recognition restarted');
                    } catch(e) {
                        console.log('[DEBUG] recognition restart failed:', e.message);
                    }
                }, 100);
            }
        };
        recognition.onerror = (event) => {
            console.error('Speech recognition error:', event.error);
            if (event.error === 'not-allowed') {
                alert('ãƒã‚¤ã‚¯ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ãŒæ‹’å¦ã•ã‚Œã¾ã—ãŸã€‚ãƒ–ãƒ©ã‚¦ã‚¶ã®è¨­å®šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
            } else if (event.error === 'no-speech') {
                // ç„¡è¦–ï¼ˆéŸ³å£°ãŒæ¤œå‡ºã•ã‚Œãªã‹ã£ãŸã ã‘ï¼‰
            } else {
                console.error('éŸ³å£°èªè­˜ã‚¨ãƒ©ãƒ¼:', event.error);
            }
        };
    }

    function speak(text, onComplete = null) {
        const cleanText = cleanTextForSpeech(text);
        isInterviewerSpeaking = true;
        updateStatus('speaking', 'AIãŒè©±ã—ã¦ã„ã¾ã™...');
        console.log('[DEBUG] speak() called, text length:', cleanText.length);

        const skipBtn = document.getElementById('skip-btn');
        if (skipBtn) skipBtn.style.display = 'inline-block';

        const utterance = new SpeechSynthesisUtterance(cleanText);
        configureUtterance(utterance);

        utterance.onend = () => {
            console.log('[DEBUG] utterance.onend fired, synth.pending:', synth.pending);
            if(skipBtn) skipBtn.style.display = 'none';
            if (!synth.pending) {
                isInterviewerSpeaking = false;
                isThinking = false;
                if (onComplete) { onComplete(); return; }
                if(!document.querySelector('.status-error') && !document.querySelector('.status-finishing')){
                    updateStatus('listening', 'èã„ã¦ã„ã¾ã™...'); toggleVisualizer(true);
                    try {
                        recognition.start();
                        console.log('[DEBUG] recognition.start() called');
                    } catch(e) {
                        console.log("[DEBUG] recognition.start() error:", e.message);
                    }
                }
            }
        };

        utterance.onerror = (e) => {
            console.error('[DEBUG] utterance.onerror:', e.error);
        };

        synth.speak(utterance);
        console.log('[DEBUG] synth.speak() called');
    }

    function setupVisualizerCanvas() {
        const canvas = document.getElementById("visualizer");
        canvasCtx = canvas.getContext("2d");
        canvasCtx.fillStyle = '#222'; canvasCtx.fillRect(0, 0, canvas.width, canvas.height);
    }
    async function initAudioContext() {
        if (audioContext) return;
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const source = audioContext.createMediaStreamSource(stream);
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 2048; source.connect(analyser);
        dataArray = new Uint8Array(analyser.frequencyBinCount);
        drawVisualizer();
    }
    function drawVisualizer() {
        visualizerFrame = requestAnimationFrame(drawVisualizer);
        if (!analyser) return;
        analyser.getByteTimeDomainData(dataArray);
        const canvas = document.getElementById("visualizer");
        const width = canvas.width; const height = canvas.height;
        canvasCtx.fillStyle = '#222'; canvasCtx.fillRect(0, 0, width, height);
        canvasCtx.lineWidth = 2; canvasCtx.strokeStyle = '#00ffcc'; canvasCtx.beginPath();
        const sliceWidth = width * 1.0 / dataArray.length; let x = 0;
        for (let i = 0; i < dataArray.length; i++) {
            const v = dataArray[i] / 128.0; const y = v * height / 2;
            if (i === 0) canvasCtx.moveTo(x, y); else canvasCtx.lineTo(x, y);
            x += sliceWidth;
        }
        canvasCtx.lineTo(canvas.width, canvas.height / 2); canvasCtx.stroke();
    }
    function toggleVisualizer(isActive) { document.getElementById('visualizer-container').classList.toggle('inactive-visualizer', !isActive); }
    function updateStatus(state, text) {
        const el = document.getElementById('status'); el.className = 'status-box status-' + state; el.innerText = text;
    }
    function addMessage(role, text) {
        const log = document.getElementById('chat-log'); const div = document.createElement('div');
        div.className = `message role-${role}`; div.innerHTML = (role === 'ai' ? 'ğŸ¤– ' : 'ğŸ‘¤ ') + text;
        log.appendChild(div); log.scrollTop = log.scrollHeight;
    }

    // ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰é–¢é€£ã®é–¢æ•°
    function toggleDebugMode() {
        debugMode = document.getElementById('debug-mode-toggle').checked;
        const debugBox = document.getElementById('debug-box');
        debugBox.classList.toggle('active', debugMode);
    }

    function addDebugEntry(status, systemPrompt, messages, response = null) {
        try {
            const timestamp = new Date().toLocaleTimeString();
            const historyCount = messages.filter(m => m.role !== 'system').length;

            // promptLogã«è¨˜éŒ²ï¼ˆAIã®å¿œç­”ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã¨ç´ä»˜ã‘ï¼‰
            const logEntry = {
                timestamp: timestamp,
                status: status,
                systemPrompt: systemPrompt,
                messages: JSON.parse(JSON.stringify(messages)), // ãƒ‡ã‚£ãƒ¼ãƒ—ã‚³ãƒ”ãƒ¼
                response: response,
                aiResponseIndex: conversationHistory.filter(h => h.role === 'assistant').length
            };
            promptLog.push(logEntry);

            // ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰ãŒONã®å ´åˆã®ã¿ç”»é¢ã«è¡¨ç¤º
            if (!debugMode) return;

            const debugBox = document.getElementById('debug-box');
            const entry = document.createElement('div');
            entry.className = 'debug-entry';
            entry.id = `debug-entry-${promptLog.length - 1}`;

            // ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’çŸ­ç¸®è¡¨ç¤ºï¼ˆæœ€åˆã®500æ–‡å­—ï¼‰
            const shortPrompt = systemPrompt.length > 500
                ? systemPrompt.substring(0, 500) + '...(truncated)'
                : systemPrompt;

            // é€ä¿¡ã™ã‚‹ä¼šè©±å±¥æ­´ã‚’æ•´å½¢
            const historyMessages = messages.filter(m => m.role !== 'system');
            const historyHtml = historyMessages.map(m => {
                const roleLabel = m.role === 'user' ? 'ğŸ‘¤ User' : 'ğŸ¤– AI';
                const shortContent = m.content.length > 100 ? m.content.substring(0, 100) + '...' : m.content;
                return `<div style="margin: 3px 0; padding: 3px 6px; background: ${m.role === 'user' ? '#3a3a5a' : '#2a4a2a'}; border-radius: 3px;"><strong>${roleLabel}:</strong> ${escapeHtml(shortContent)}</div>`;
            }).join('');

            entry.innerHTML = `
                <div class="debug-timestamp">${timestamp}</div>
                <div class="debug-status">ğŸ“¡ ${status}</div>
                <div style="color: #aaa; margin-top: 8px;">System Prompt (ãƒˆãƒ”ãƒƒã‚¯çŠ¶æ³å«ã‚€):</div>
                <div class="debug-prompt">${escapeHtml(shortPrompt)}</div>
                <div style="color: #aaa; margin-top: 8px;">ğŸ“œ é€ä¿¡ã™ã‚‹ä¼šè©±å±¥æ­´ (${historyCount}ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸):</div>
                <div class="debug-prompt" style="color: #ff9; max-height: 120px;">${historyHtml || '<em>ãªã—</em>'}</div>
                <div class="debug-response-area"></div>
            `;

            debugBox.insertBefore(entry, debugBox.firstChild);

            // æœ€å¤§10ä»¶ã¾ã§ã«åˆ¶é™
            while (debugBox.children.length > 10) {
                debugBox.removeChild(debugBox.lastChild);
            }
        } catch (e) {
            console.error('Debug entry error:', e);
        }
    }

    function updateDebugEntryResponse(response) {
        try {
            if (!debugMode) return;

            const entryId = `debug-entry-${promptLog.length - 1}`;
            const entry = document.getElementById(entryId);
            if (entry) {
                const statusEl = entry.querySelector('.debug-status');
                if (statusEl) {
                    statusEl.innerHTML = 'âœ… Response Received';
                    statusEl.style.color = '#98fb98';
                }
                const responseArea = entry.querySelector('.debug-response-area');
                if (responseArea && response) {
                    responseArea.innerHTML = `
                        <div style="color: #aaa; margin-top: 8px;">Response:</div>
                        <div class="debug-prompt" style="color: #98fb98;">${escapeHtml(response.substring(0, 300))}${response.length > 300 ? '...' : ''}</div>
                    `;
                }
            }
        } catch (e) {
            console.error('Debug update error:', e);
        }
    }

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
</script>

</body>
</html>