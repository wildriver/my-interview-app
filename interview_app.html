<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Interviewer (Running - v12)</title>
    <style>
        body { font-family: "Helvetica Neue", Arial, sans-serif; max-width: 900px; margin: 0 auto; padding: 20px; background-color: #f0f2f5; color: #333; position: relative; }
        .container { background: white; padding: 30px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); }
        h2 { text-align: center; color: #444; margin-bottom: 5px; }
        .subtitle { text-align: center; color: #777; font-size: 0.9em; margin-bottom: 20px; }
        
        #timer {
            position: absolute; top: 20px; right: 20px;
            font-size: 1.5em; font-weight: bold; color: #555;
            background: #fff; padding: 5px 15px; border-radius: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .status-box { padding: 12px; margin-bottom: 10px; text-align: center; font-weight: bold; border-radius: 8px; transition: all 0.3s; }
        .status-idle { background-color: #e9ecef; color: #6c757d; }
        .status-listening { background-color: #ffebee; color: #c62828; border: 1px solid #ffcdd2; animation: pulse 2s infinite; }
        .status-thinking { background-color: #e3f2fd; color: #1565c0; border: 1px solid #bbdefb; }
        .status-speaking { background-color: #e8f5e9; color: #2e7d32; border: 1px solid #c8e6c9; }
        .status-finishing { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .status-error { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }

        #visualizer-container { height: 60px; background-color: #222; border-radius: 8px; margin-bottom: 20px; display: flex; overflow: hidden; }
        canvas { display: block; width: 100%; height: 100%; }
        .inactive-visualizer { opacity: 0.3; filter: grayscale(100%); }
        
        .content-wrapper { display: flex; gap: 20px; flex-wrap: wrap; }
        .chat-section { flex: 1; min-width: 300px; }
        .summary-section { flex: 1; min-width: 300px; display: none; }
        #chat-log { height: 400px; overflow-y: auto; border: 1px solid #dee2e6; padding: 20px; background: #fafafa; border-radius: 8px; }
        
        .message { margin-bottom: 15px; padding: 12px 16px; border-radius: 12px; max-width: 90%; line-height: 1.5; }
        .role-user { background-color: #007bff; color: white; margin-left: auto; border-bottom-right-radius: 2px; }
        .role-ai { background-color: #fff; border: 1px solid #e9ecef; margin-right: auto; border-bottom-left-radius: 2px; }
        
        #summary-box { height: 350px; overflow-y: auto; border: 2px solid #28a745; padding: 20px; background: #fff; border-radius: 8px; line-height: 1.8; white-space: pre-wrap; margin-bottom: 10px; }
        .summary-title { font-weight: bold; color: #28a745; margin-bottom: 10px; }

        /* --- ãƒœã‚¿ãƒ³ã‚¨ãƒªã‚¢ã®ã‚¹ã‚¿ã‚¤ãƒ« --- */
        .controls { margin-top: 20px; }
        
        /* å…±é€šãƒœã‚¿ãƒ³ã‚¹ã‚¿ã‚¤ãƒ« */
        .btn { 
            padding: 15px 30px; font-size: 1.1em; font-weight: bold; 
            cursor: pointer; border: none; border-radius: 50px; 
            color: white; transition: all 0.2s; width: 100%;
        }
        .btn:hover { opacity: 0.9; transform: translateY(-1px); }
        .btn:active { transform: translateY(1px); }

        .btn-start { background-color: #007bff; max-width: 400px; display: block; margin: 0 auto; }
        .btn-abort { background-color: #dc3545; }
        .btn-finish { background-color: #28a745; }
        .btn-back { background-color: #6c757d; max-width: 400px; display: block; margin: 0 auto; }

        /* å®Ÿè¡Œä¸­ã®ãƒœã‚¿ãƒ³ã‚³ãƒ³ãƒ†ãƒŠï¼ˆæ¨ªä¸¦ã³ï¼‰ */
        .running-controls {
            display: flex; gap: 15px; justify-content: center;
            width: 100%; max-width: 600px; margin: 0 auto;
        }
        .running-controls button { flex: 1; }

        /* ã‚¹ã‚­ãƒƒãƒ—ãƒœã‚¿ãƒ³ */
        #skip-btn-container { text-align: center; margin-bottom: 15px; height: 40px; }
        #skip-btn {
            background-color: #6c757d; color: white; border: none; 
            padding: 8px 25px; border-radius: 30px; font-weight: bold; font-size: 0.9em;
            cursor: pointer; display: none;
        }
        #skip-btn:hover { background-color: #5a6268; }

        .copy-btn { width: 100%; padding: 10px; background-color: #6c757d; color: white; border: none; border-radius: 5px; cursor: pointer; }

        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.6; } 100% { opacity: 1; } }
    </style>
</head>
<body>

<div id="timer">00:00</div>

<div class="container">
    <h2 id="page-title">ã‚¤ãƒ³ã‚¿ãƒ“ãƒ¥ãƒ¼</h2>
    <div class="subtitle" id="page-topics">èª­ã¿è¾¼ã¿ä¸­...</div>
    <div id="status" class="status-box status-idle">å¾…æ©Ÿä¸­</div>
    
    <div id="visualizer-container" class="inactive-visualizer">
        <canvas id="visualizer" width="600" height="100"></canvas>
    </div>

    <div class="content-wrapper">
        <div class="chat-section"><div id="chat-log"></div></div>
        <div class="summary-section" id="summary-section">
            <div class="summary-title">ğŸ“ ã‚¤ãƒ³ã‚¿ãƒ“ãƒ¥ãƒ¼çµæœã‚µãƒãƒªãƒ¼</div>
            <div id="summary-box">ã“ã“ã«çµæœãŒè¡¨ç¤ºã•ã‚Œã¾ã™...</div>
            <button class="copy-btn" onclick="copySummary()">ğŸ“‹ ã‚µãƒãƒªãƒ¼ã‚’ã‚³ãƒ”ãƒ¼</button>
        </div>
    </div>

    <div class="controls">
        <div id="skip-btn-container">
            <button id="skip-btn" onclick="skipSpeech()">â© è©±ã™ã®ã‚’ã‚„ã‚ã¦èã (Skip)</button>
        </div>

        <div id="ctrl-idle">
            <button class="btn btn-start" onclick="startInterview()">ã‚¤ãƒ³ã‚¿ãƒ“ãƒ¥ãƒ¼é–‹å§‹</button>
        </div>

        <div id="ctrl-running" class="running-controls" style="display:none;">
            <button class="btn btn-abort" onclick="abortInterview()">ä¸­æ­¢ã™ã‚‹<br><span style="font-size:0.7em; font-weight:normal">(ä¿å­˜ã•ã‚Œã¾ã›ã‚“)</span></button>
            <button class="btn btn-finish" onclick="forceFinish()">çµ‚äº†ã™ã‚‹<br><span style="font-size:0.7em; font-weight:normal">(ã‚µãƒãƒªãƒ¼ç”Ÿæˆ)</span></button>
        </div>

        <div id="ctrl-finished" style="display:none;">
            <button class="btn btn-back" onclick="window.location.href='index.html'">è¨­å®šç”»é¢ã«æˆ»ã‚‹</button>
        </div>
    </div>
</div>

<script>
    const FILLERS = ["ãªã‚‹ã»ã©", "ãªã‚‹ã»ã©ã‰", "ãªãƒ¼ã‚‹ã»ã©", "ãªããƒ¼ã‚‹ã»ã©", "ãªã‚‹ã»ã©ã§ã™ã­ã‡", "ãµã‚€ãµã‚€", "ãµã…ã‚€ãµã‚€", "ãµã‚€ãµã‚€ãµã‚€"];
    const DB_NAME = "InterviewDB";
    const DB_VERSION = 1;
    const STORE_NAME = "archives";

    let CONFIG = {}; 
    let recognition;
    let isInterviewerSpeaking = false; 
    let isThinking = false; 
    let conversationHistory = [];      
    let synth = window.speechSynthesis;
    let audioContext, analyser, dataArray, canvasCtx, visualizerFrame;
    let availableVoices = [];
    
    let timerInterval;
    let startTime;

    let currentTopicIndex = 0;
    let currentTopicTurnCount = 0; 
    let targetDepth = 3; 

    window.speechSynthesis.onvoiceschanged = () => { availableVoices = window.speechSynthesis.getVoices(); };

    window.onload = () => {
        const storedConfig = localStorage.getItem('interviewConfig');
        if (storedConfig) {
            CONFIG = JSON.parse(storedConfig);
        } else {
            alert("è¨­å®šç”»é¢ã‹ã‚‰èµ·å‹•ã—ã¦ãã ã•ã„ã€‚");
            window.location.href = 'index.html';
            return;
        }

        document.getElementById('page-title').innerText = CONFIG.title;
        document.getElementById('page-topics').innerText = "èããŸã„ã“ã¨: " + CONFIG.topics.length + "é …ç›®";
        
        targetDepth = CONFIG.depth === "deep" ? 5 : 3;

        setupRecognition();
        setupVisualizerCanvas();
        setButtonState("IDLE");
    };

    function setButtonState(state) {
        document.getElementById('ctrl-idle').style.display = 'none';
        document.getElementById('ctrl-running').style.display = 'none';
        document.getElementById('ctrl-finished').style.display = 'none';
        document.getElementById('skip-btn').style.display = 'none';

        if (state === "IDLE") {
            document.getElementById('ctrl-idle').style.display = 'block';
        } else if (state === "RUNNING") {
            document.getElementById('ctrl-running').style.display = 'flex';
        } else if (state === "FINISHED") {
            document.getElementById('ctrl-finished').style.display = 'block';
        }
    }

    function abortInterview() {
        if (confirm("ã‚¤ãƒ³ã‚¿ãƒ“ãƒ¥ãƒ¼ã‚’ä¸­æ­¢ã—ã¾ã™ã‹ï¼Ÿ\nï¼ˆå†…å®¹ã¯ä¿å­˜ã•ã‚Œã¾ã›ã‚“ï¼‰")) {
            stopRecognition();
            clearInterval(timerInterval);
            window.location.href = 'index.html';
        }
    }

    function forceFinish() {
        if (confirm("ç¾åœ¨ã¾ã§ã®å†…å®¹ã§ã‚¤ãƒ³ã‚¿ãƒ“ãƒ¥ãƒ¼ã‚’çµ‚äº†ã—ã€ã‚µãƒãƒªãƒ¼ã‚’ä½œæˆã—ã¾ã™ã‹ï¼Ÿ")) {
            stopTimer();
            stopRecognition();
            updateStatus('finishing', 'çµ‚äº†å‡¦ç†ä¸­... ã‚µãƒãƒªãƒ¼ã‚’ä½œæˆã—ã¾ã™');
            document.getElementById('ctrl-running').style.display = 'none'; 
            generateSummary();
        }
    }

    function startTimer() {
        startTime = Date.now();
        clearInterval(timerInterval);
        timerInterval = setInterval(() => {
            const diff = Date.now() - startTime;
            const mins = Math.floor(diff / 60000);
            const secs = Math.floor((diff % 60000) / 1000);
            document.getElementById('timer').innerText = 
                (mins < 10 ? "0" : "") + mins + ":" + (secs < 10 ? "0" : "") + secs;
        }, 1000);
    }

    function stopTimer() {
        clearInterval(timerInterval);
    }

    function skipSpeech() {
        if (synth.speaking || synth.pending) {
            synth.cancel(); 
            isInterviewerSpeaking = false;
            isThinking = false;
            document.getElementById('skip-btn').style.display = 'none';
            
            if (!document.querySelector('.status-finishing')) {
                updateStatus('listening', 'èã„ã¦ã„ã¾ã™...'); 
                toggleVisualizer(true);
                try { recognition.start(); } catch(e) { console.log("Mic forced active"); }
            }
        }
    }

    async function startInterview() {
        if (!CONFIG.apiKey) return alert("APIã‚­ãƒ¼ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“");
        
        conversationHistory = []; 
        currentTopicIndex = 0;
        currentTopicTurnCount = 0;
        
        document.getElementById('chat-log').innerHTML = ''; 
        document.getElementById('summary-section').style.display = 'none'; 
        document.getElementById('summary-box').innerText = '...';

        await initAudioContext();
        setButtonState("RUNNING");
        startTimer();
        
        try { recognition.start(); } catch(e) {}

        const intro = "ã“ã‚“ã«ã¡ã¯ã€‚ã‚¤ãƒ³ã‚¿ãƒ“ãƒ¥ãƒ¼ã‚’å§‹ã‚ã¾ã™ã€‚ã¾ãšã¯è‡ªå·±ç´¹ä»‹ã‚’ãŠé¡˜ã„ã—ã¾ã™ã€‚";
        addMessage('ai', intro);
        conversationHistory.push({ role: "assistant", content: intro });
        speak(intro);
    }

    function stopRecognition() {
        isInterviewerSpeaking = false; 
        isThinking = false;
        if(recognition) recognition.stop();
        synth.cancel(); 
        toggleVisualizer(false);
    }

    async function processUserResponse(userText) {
        isThinking = true; 
        updateStatus('thinking', 'AIãŒè€ƒãˆã¦ã„ã¾ã™ (Groq)...');
        
        conversationHistory.push({ role: "user", content: userText });
        currentTopicTurnCount++;

        let nextInstruction = "";

        if (currentTopicTurnCount < targetDepth) {
            const topic = CONFIG.topics[currentTopicIndex];
            if (currentTopicTurnCount === 1) {
                // 1å›ç›®ã¯æ·±æ˜ã‚Š
                nextInstruction = `ç¾åœ¨ã€ãƒˆãƒ”ãƒƒã‚¯ã€Œ${topic}ã€ã«ã¤ã„ã¦è©±ã—ã¦ã„ã¾ã™ã€‚
ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å›ç­”ã‚’å—ã‘ã¦ã€ç†ç”±ã‚„å…·ä½“çš„ãªã‚¨ãƒ”ã‚½ãƒ¼ãƒ‰ã‚’æ·±æ˜ã‚Šã—ã¦ãã ã•ã„ã€‚`;
            } else {
                // 2å›ç›®ä»¥é™ã¯åºƒã’ã‚‹
                nextInstruction = `ç¾åœ¨ã€ãƒˆãƒ”ãƒƒã‚¯ã€Œ${topic}ã€ã«ã¤ã„ã¦è©±ã—ã¦ã„ã¾ã™ã€‚
**ã€Œä»–ã«ã¯ï¼Ÿã€ã€Œåˆ¥ã®è¦–ç‚¹ã§ã¯ï¼Ÿã€**ã¨ã€è©±é¡Œã‚’åºƒã’ã‚‹è³ªå•ã‚’ã—ã¦ãã ã•ã„ã€‚`;
            }
        } else {
            currentTopicIndex++;
            currentTopicTurnCount = 0;

            if (currentTopicIndex < CONFIG.topics.length) {
                const nextTopic = CONFIG.topics[currentTopicIndex];
                // ãƒˆãƒ”ãƒƒã‚¯åˆ‡ã‚Šæ›¿ãˆæŒ‡ç¤ºï¼ˆå‰ç½®ããªã—ã§è³ªå•ã•ã›ã‚‹ï¼‰
                nextInstruction = `ã“ã®è©±é¡Œã¯ååˆ†ã§ã™ã€‚
**å³åº§ã«æ¬¡ã®ãƒˆãƒ”ãƒƒã‚¯ã€Œ${nextTopic}ã€ã«ã¤ã„ã¦ã®è³ªå•**ã‚’ã—ã¦ãã ã•ã„ã€‚`;
            } else {
                nextInstruction = `å…¨ã¦ã®ãƒˆãƒ”ãƒƒã‚¯ãŒçµ‚äº†ã—ã¾ã—ãŸã€‚
**ã€Œæœ€å¾Œã«è¨€ã„æ®‹ã—ãŸã“ã¨ã¯ã‚ã‚Šã¾ã™ã‹ï¼Ÿã€**ã¨èã„ã¦ãã ã•ã„ã€‚`;
                
                if (currentTopicIndex > CONFIG.topics.length) { 
                    nextInstruction = `**ã‚¤ãƒ³ã‚¿ãƒ“ãƒ¥ãƒ¼ã‚’çµ‚äº†ã™ã‚‹æŒ¨æ‹¶**ã‚’ã—ã¦ãã ã•ã„ã€‚æ„Ÿè¬ã‚’ä¼ãˆã€ã€Œãã‚Œã§ã¯ã‚¤ãƒ³ã‚¿ãƒ“ãƒ¥ãƒ¼ã‚’çµ‚äº†ã—ã¾ã™ã€ã¨è¨€ã£ã¦ãã ã•ã„ã€‚`;
                }
                currentTopicIndex++; 
            }
        }

        if (userText.includes("ã‚„ã‚ã¦") || userText.includes("çµ‚äº†ã—ã¦") || userText.includes("ã‚¹ãƒˆãƒƒãƒ—")) {
            nextInstruction = `ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒçµ‚äº†ã‚’å¸Œæœ›ã—ã¦ã„ã¾ã™ã€‚è¬ç½ªã—ã€ç›´ã¡ã«ã€Œãã‚Œã§ã¯ã‚¤ãƒ³ã‚¿ãƒ“ãƒ¥ãƒ¼ã‚’çµ‚äº†ã—ã¾ã™ã€ã¨è¨€ã£ã¦ç· ã‚ããã£ã¦ãã ã•ã„ã€‚`;
        }

        try {
            const systemPrompt = buildDynamicPrompt(nextInstruction);
            // â˜…é‡è¦ï¼šå±¥æ­´ã‚¹ãƒ©ã‚¤ãƒ‰å‡¦ç†ã‚’å«ã‚“ã APIå‘¼ã³å‡ºã—
            const aiText = await callGroqAPI(conversationHistory, systemPrompt);

            addMessage('ai', aiText);
            conversationHistory.push({ role: "assistant", content: aiText });
            
            if (aiText.includes("çµ‚äº†ã—ã¾ã™") || aiText.includes("çµ‚ã‚ã‚Šã¾ã™")) {
                stopTimer();
                updateStatus('finishing', 'æŒ¨æ‹¶ã®èª­ã¿ä¸Šã’ä¸­...');
                
                speak(aiText, () => {
                    updateStatus('finishing', 'ã‚µãƒãƒªãƒ¼ä½œæˆä¸­...');
                    stopRecognition();
                    generateSummary();
                });
            } else {
                speak(aiText);
            }

        } catch (error) {
            console.error(error);
            addMessage('ai', `<span class="error-msg">${error.message}</span>`);
            speak("ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚");
            updateStatus('error', 'ã‚¨ãƒ©ãƒ¼');
            isThinking = false;
        }
    }

    function buildDynamicPrompt(instruction) {
        const contextText = CONFIG.context ? `\n# Pre-knowledge / Background Context\n${CONFIG.context}\n` : "";
        
        return `
# Persona
${CONFIG.persona}

${contextText}

# Instruction
${instruction}

# Strict Rules
1. **å›ç­”è€…ã®ç™ºè¨€ã‚’ã‚ªã‚¦ãƒ è¿”ã—ã—ãŸã‚Šã€è¦ç´„ã—ãŸã‚Šã—ãªã„ã§ãã ã•ã„ã€‚** ï¼ˆã€Œã€œã¨ã„ã†ã“ã¨ã§ã™ã­ã€ã€Œã€œãªã‚“ã§ã™ã­ã€ã¯ç¦æ­¢ï¼‰
2. **å‰ç½®ããªã—ã§ã€ã™ãã«è³ªå•ã‚’æŠ•ã’ã‹ã‘ã¦ãã ã•ã„ã€‚**
3. ç™ºè¨€ã®æœ€å¾Œã¯å¿…ãš**è³ªå•**ã§çµ‚ã‚ã£ã¦ãã ã•ã„ã€‚
4. çµ‚äº†ã™ã‚‹æ™‚ä»¥å¤–ã¯ã€ã€Œçµ‚äº†ã—ã¾ã™ã€ã¨è¨€ã‚ãªã„ã§ãã ã•ã„ã€‚
`;
    }

    // --- API Call (Token optimization) ---
    async function callGroqAPI(history, systemPrompt, customTemp = 0.7, customMaxTokens = 1024) {
        const url = "https://api.groq.com/openai/v1/chat/completions";
        
        // â˜…ãƒˆãƒ¼ã‚¯ãƒ³ç¯€ç´„ãƒ­ã‚¸ãƒƒã‚¯: å±¥æ­´ã¯ç›´è¿‘ã®10ä»¶ï¼ˆ5å¾€å¾©ï¼‰ã®ã¿é€ä¿¡ã™ã‚‹
        const MAX_HISTORY = 10;
        const recentHistory = history.length > MAX_HISTORY ? history.slice(-MAX_HISTORY) : history;

        const messages = [{ role: "system", content: systemPrompt }, ...recentHistory];

        const payload = {
            model: CONFIG.modelName || "llama-3.3-70b-versatile",
            messages: messages,
            temperature: customTemp, 
            max_tokens: customMaxTokens
        };

        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${CONFIG.apiKey}`
            },
            body: JSON.stringify(payload)
        });

        if (!response.ok) {
            const err = await response.json().catch(() => ({}));
            // Rate Limitã‚¨ãƒ©ãƒ¼ã®å ´åˆã¯ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«åˆ†ã‹ã‚Šã‚„ã™ãè¡¨ç¤º
            if (response.status === 429) {
                throw new Error("Rate Limit Exceeded: 1æ—¥ã®åˆ©ç”¨åˆ¶é™ã«é”ã—ã¾ã—ãŸã€‚æ™‚é–“ã‚’ãŠã„ã¦è©¦ã—ã¦ãã ã•ã„ã€‚");
            }
            throw new Error(`Groq API Error: ${err.error?.message || response.statusText}`);
        }

        const data = await response.json();
        return data.choices[0].message.content;
    }

    async function generateSummary() {
        const summarySection = document.getElementById('summary-section');
        summarySection.style.display = 'block';
        const summaryBox = document.getElementById('summary-box');
        summaryBox.innerText = "é•·æ–‡ã‚µãƒãƒªãƒ¼ç”Ÿæˆä¸­...";

        const historyText = conversationHistory.map(item => `${item.role}: ${item.content}`).join("\n");
        const prompt = `ä»¥ä¸‹ã®ãƒ­ã‚°ã‚’å…ƒã«ã€è©³ç´°ãªãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ã‚¿ãƒªãƒ¼è¨˜äº‹ã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚\n\nã€ãƒ­ã‚°ã€‘\n${historyText}`;
        
        try {
            // ã‚µãƒãƒªãƒ¼ç”Ÿæˆæ™‚ã¯å±¥æ­´ã‚’é€ã‚‰ãšã€ãƒ†ã‚­ã‚¹ãƒˆåŒ–ã—ã¦é€ã‚‹ï¼ˆã“ã‚Œã¯å¤‰ãˆãªã„ï¼‰
            // Summaryæ™‚ã¯ãƒˆãƒ¼ã‚¯ãƒ³æ¶ˆè²»ãŒå¤šã„ãŒ1å›ã ã‘ãªã®ã§è¨±å®¹ã™ã‚‹ã€‚
            const summaryText = await callGroqAPI([{ role: "user", content: prompt }], "ã‚ãªãŸã¯å„ªç§€ãªãƒ©ã‚¤ã‚¿ãƒ¼ã§ã™ã€‚", 0.7, 4096);
            summaryBox.innerText = summaryText;
            updateStatus('idle', 'å®Œäº†');
            setButtonState("FINISHED"); 
            await saveToDB(summaryText);
        } catch (error) {
            summaryBox.innerHTML = `<span style="color:red;">${error.message}</span>`;
            updateStatus('error', 'ã‚¨ãƒ©ãƒ¼');
        }
    }

    function openDB() {
        return new Promise((r, j) => {
            const req = indexedDB.open(DB_NAME, DB_VERSION);
            req.onupgradeneeded = (e) => { 
                const db = e.target.result; 
                if (!db.objectStoreNames.contains(STORE_NAME)) db.createObjectStore(STORE_NAME, { keyPath: "id" });
            };
            req.onsuccess = (e) => r(e.target.result);
            req.onerror = (e) => j(e.target.error);
        });
    }

    async function saveToDB(summaryText) {
        try {
            const db = await openDB();
            const tx = db.transaction(STORE_NAME, "readwrite");
            const store = tx.objectStore(STORE_NAME);
            const record = {
                id: Date.now(), title: CONFIG.title, date: new Date().toLocaleString(),
                topics: CONFIG.topics, history: conversationHistory, summary: summaryText
            };
            store.add(record);
        } catch (e) { console.error("DB Error:", e); }
    }

    function copySummary() {
        const text = document.getElementById('summary-box').innerText;
        navigator.clipboard.writeText(text).then(() => alert("ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸï¼"));
    }

    function cleanTextForSpeech(text) { return text.replace(/[\*#_`~]/g, ''); }

    function configureUtterance(utterance) {
        utterance.rate = CONFIG.rate; utterance.volume = 1.0; utterance.pitch = 1.0; 
        if (availableVoices.length === 0) availableVoices = window.speechSynthesis.getVoices();
        const selectedVoice = availableVoices.find(v => v.name === CONFIG.voiceName);
        if (selectedVoice) utterance.voice = selectedVoice;
    }
    
    function setupRecognition() {
        if (!('webkitSpeechRecognition' in window)) return alert("Chromeãƒ–ãƒ©ã‚¦ã‚¶ã§é–‹ã„ã¦ãã ã•ã„");
        recognition = new webkitSpeechRecognition();
        recognition.lang = 'ja-JP'; recognition.continuous = true; recognition.interimResults = false;
        recognition.onstart = () => { updateStatus('listening', 'èã„ã¦ã„ã¾ã™...'); toggleVisualizer(true); };
        recognition.onresult = (event) => {
            const transcript = event.results[event.results.length - 1][0].transcript.trim();
            if (!transcript) return;
            if (isInterviewerSpeaking || isThinking) return;
            addMessage('user', transcript);
            if (Math.random() <= CONFIG.fillerFreq) playFiller();
            processUserResponse(transcript); 
        };
        recognition.onend = () => { toggleVisualizer(false); };
        recognition.onerror = (event) => {
            console.error('Speech recognition error:', event.error);
            if (event.error === 'not-allowed') {
                alert('ãƒã‚¤ã‚¯ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ãŒæ‹’å¦ã•ã‚Œã¾ã—ãŸã€‚ãƒ–ãƒ©ã‚¦ã‚¶ã®è¨­å®šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
            } else if (event.error === 'no-speech') {
                // ç„¡è¦–ï¼ˆéŸ³å£°ãŒæ¤œå‡ºã•ã‚Œãªã‹ã£ãŸã ã‘ï¼‰
            } else {
                console.error('éŸ³å£°èªè­˜ã‚¨ãƒ©ãƒ¼:', event.error);
            }
        };
    }

    function playFiller() {
        const text = FILLERS[Math.floor(Math.random() * FILLERS.length)];
        const utterance = new SpeechSynthesisUtterance(text);
        configureUtterance(utterance); 
        utterance.rate = 0.8; utterance.pitch = 0.9; utterance.volume = 0.5; 
        isInterviewerSpeaking = true; synth.speak(utterance); 
    }

    function speak(text, onComplete = null) {
        const cleanText = cleanTextForSpeech(text);
        isInterviewerSpeaking = true; 
        updateStatus('speaking', 'AIãŒè©±ã—ã¦ã„ã¾ã™...');
        
        const skipBtn = document.getElementById('skip-btn');
        if (skipBtn) skipBtn.style.display = 'inline-block';

        const utterance = new SpeechSynthesisUtterance(cleanText);
        configureUtterance(utterance);
        
        utterance.onend = () => {
            if(skipBtn) skipBtn.style.display = 'none';
            if (!synth.pending) { 
                isInterviewerSpeaking = false;
                isThinking = false;
                if (onComplete) { onComplete(); return; }
                if(!document.querySelector('.status-error') && !document.querySelector('.status-finishing')){
                     updateStatus('listening', 'èã„ã¦ã„ã¾ã™...'); toggleVisualizer(true);
                     try { recognition.start(); } catch(e) { console.log("Mic active"); }
                }
            }
        };
        synth.speak(utterance);
    }

    function setupVisualizerCanvas() {
        const canvas = document.getElementById("visualizer");
        canvasCtx = canvas.getContext("2d");
        canvasCtx.fillStyle = '#222'; canvasCtx.fillRect(0, 0, canvas.width, canvas.height);
    }
    async function initAudioContext() {
        if (audioContext) return;
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const source = audioContext.createMediaStreamSource(stream);
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 2048; source.connect(analyser);
        dataArray = new Uint8Array(analyser.frequencyBinCount);
        drawVisualizer();
    }
    function drawVisualizer() {
        visualizerFrame = requestAnimationFrame(drawVisualizer);
        if (!analyser) return;
        analyser.getByteTimeDomainData(dataArray);
        const canvas = document.getElementById("visualizer");
        const width = canvas.width; const height = canvas.height;
        canvasCtx.fillStyle = '#222'; canvasCtx.fillRect(0, 0, width, height);
        canvasCtx.lineWidth = 2; canvasCtx.strokeStyle = '#00ffcc'; canvasCtx.beginPath();
        const sliceWidth = width * 1.0 / dataArray.length; let x = 0;
        for (let i = 0; i < dataArray.length; i++) {
            const v = dataArray[i] / 128.0; const y = v * height / 2;
            if (i === 0) canvasCtx.moveTo(x, y); else canvasCtx.lineTo(x, y);
            x += sliceWidth;
        }
        canvasCtx.lineTo(canvas.width, canvas.height / 2); canvasCtx.stroke();
    }
    function toggleVisualizer(isActive) { document.getElementById('visualizer-container').classList.toggle('inactive-visualizer', !isActive); }
    function updateStatus(state, text) {
        const el = document.getElementById('status'); el.className = 'status-box status-' + state; el.innerText = text;
    }
    function addMessage(role, text) {
        const log = document.getElementById('chat-log'); const div = document.createElement('div');
        div.className = `message role-${role}`; div.innerHTML = (role === 'ai' ? 'ğŸ¤– ' : 'ğŸ‘¤ ') + text;
        log.appendChild(div); log.scrollTop = log.scrollHeight;
    }
</script>

</body>
</html>